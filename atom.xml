<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>WebCraft</title>
   <link href="http://webcraft.malei.tk/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://webcraft.malei.tk" rel="alternate" type="text/html" />
   <updated>2012-09-14T19:22:13+08:00</updated>
   <id>http://webcraft.malei.tk</id>
   <author>
     <name>Lei Ma</name>
     <email>leiman0311@gmail.com</email>
   </author>

   
   <entry>
     <title>img 中alt和tittle的区别</title>
     <link href="http://webcraft.malei.tk/articles/the-diff-between-alt-and-title"/>
     <updated>2012-09-14T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/the-diff-between-alt-and-title</id>
     <content type="html">&lt;h2&gt;总述&lt;/h2&gt;

&lt;p&gt;简单的理解：
alt：  图片显示不出来了就显示alt的属性值
title：鼠标划过图片显示的提示&lt;/p&gt;

&lt;h2&gt;alt属性&lt;/h2&gt;

&lt;p&gt;使用alt属性是为了给那些不能看到你文档中图像的浏览者提供文字说明。这包括那些使用本来就不支持图像显示或者图像显示被关闭的浏览器的用户，视觉障碍的用户和使用屏幕阅读器的用户。替换文字是用来替代图像而不是提供额外说明文字的。在写替换文字前仔细想想，保证那些文字确实为那些看不到图像的人提供了说明信息，并且在上下文中有意义。对于那些装饰性的图片可以使用空的值(alt=&quot;&quot;，引号中间没有空格)，而不是使用不相关的替换文字比如“foo”或者“foo.gif”。不要忽略它，如果你忽略了，那么一些屏幕阅读器会直接阅读图像文件的文件名，那些文字浏览器，比如Lynx会显示图像文件的文件名，而那对于你的浏览者就没什么用了。包含文字的图像图片设置替换文字是最简单的，图像中包含的文字一般来说就可以作为alt属性值。&lt;/p&gt;

&lt;h2&gt;title属性&lt;/h2&gt;

&lt;p&gt;title属性有一个很好的用途，即为链接添加描述性文字，特别是当连接本身并不是十分清楚的表达了链接的目的。这样就使得访问者知道那些链接将会带他们到什么地方，他们就不会加载一个可能完全不感兴趣的页面。对于img标签，title是对图片的说明和额外补充，如果需要在鼠标经过图片时出现文字提示应该用属性title。&lt;/p&gt;

&lt;h2&gt;测试&lt;/h2&gt;

&lt;p&gt;一段简单的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
    &amp;lt;img src=&quot;&quot; alt=&quot;test&quot; title=&quot;i'm a title&quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;chrome中的显示效果&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/articles/img-alt-vs-title/chrome.png&quot; title=&quot;chrome中的显示效果&quot; alt=&quot;chrome&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;firefox中的显示效果&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/articles/img-alt-vs-title/firefox.png&quot; title=&quot;firefox中的显示效果&quot; alt=&quot;firefox&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;ie9中的显示效果&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/articles/img-alt-vs-title/ie9.png&quot; title=&quot;ie9中的显示效果&quot; alt=&quot;ie9&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>mysql拷贝表</title>
     <link href="http://webcraft.malei.tk/articles/mysql-copy-table"/>
     <updated>2012-09-12T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/mysql-copy-table</id>
     <content type="html">&lt;h2&gt;总述&lt;/h2&gt;

&lt;p&gt;现在每个表都是按用户的意愿生成的，每个表的字段大体上相同，但是会有一两个不同的字段，该怎么做？&lt;/p&gt;

&lt;h2&gt;几种拷贝表的方式&lt;/h2&gt;

&lt;h3&gt;拷贝表结构到新表中&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE new LIKE origin;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;拷贝数据到新表中&lt;/h3&gt;

&lt;p&gt;注意：这个语句其实只是把select语句的结果建一个表。所以 new 这个表不会有主键，索引。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE new AS   
(   
    SELECT *   
    FROM origin   
); 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;真正的复制一个表&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE new LIKE origin;   
INSERT INTO new SELECT * FROM origin;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;操作不同的数据库&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE new LIKE shop.origin;   
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;新建的表的字段改名&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE new AS   
(   
    SELECT id, username AS uname, password AS pass FROM origin   
);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;实现&lt;/h2&gt;

&lt;p&gt;因为表中的字段大部分相同，所以需要找出相同的字段&lt;/p&gt;

&lt;h3&gt;获取表中的字段&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;        //获取表字段信息
    public function getColumnName($tableName){
        $sql=&amp;lt;&amp;lt;&amp;lt;EOF
        select COLUMN_NAME from INFORMATION_SCHEMA.COLUMNS where table_name=&quot;$tableName&quot;;
EOF;
        $queryResult=$this-&amp;gt;pdo-&amp;gt;query($sql);
        $resultArray=array();
        $rows=$queryResult-&amp;gt;fetchAll(PDO::FETCH_ASSOC);
        foreach ($rows as $row) {
            $resultArray[]=$row['COLUMN_NAME'];
        }
        return $resultArray;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;找出相同的字段，然后拷贝&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;        /**
     * [copyDataToNewTable 拷贝上一个月表中的数据]
     * @param  [string] $oldTableName [上一个月原表]
     * @param  [string] $newTableName [新表]
     * @return [boolean]              [返回值]
     */
    public function copyDataToNewTable($oldTableName,$newTableName){
        $whatIWant=array();
        $columnName_oldTable=$this-&amp;gt;getColumnName($oldTableName);
        $columnName_newTable=$this-&amp;gt;getColumnName($newTableName);
        foreach ($columnName_oldTable as $key1 =&amp;gt; $value1) {
            foreach ($columnName_newTable as $key2 =&amp;gt; $value2) {
                if($columnName_oldTable[$key1]==$columnName_newTable[$key2]){
                    $whatIWant[]= $columnName_oldTable[$key1];
                }
            }
        }
        $whatIWant_result=join(&quot;,&quot;,$whatIWant);
        $sql=&amp;lt;&amp;lt;&amp;lt;EOF
        insert  into `$newTableName`($whatIWant_result) select $whatIWant_result from `$oldTableName`;
EOF;
        $queryResult=$this-&amp;gt;pdo-&amp;gt;exec($sql);
        if($queryResult)
        {
            return true;
        }
        else{
            return false;
        } 
    }
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>sublime text 2 插件使用</title>
     <link href="http://webcraft.malei.tk/articles/sublime-text-2"/>
     <updated>2012-09-10T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/sublime-text-2</id>
     <content type="html">&lt;p&gt;//TODO:&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>该怎么做？</title>
     <link href="http://webcraft.malei.tk/articles/how-to-do"/>
     <updated>2012-08-29T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/how-to-do</id>
     <content type="html">&lt;h2&gt;总述&lt;/h2&gt;

&lt;p&gt;停留在实验室中的永远不能算是产品，主观臆断的东西极有可能不能满足用户的需求，做产品一定要明确针对人群，明确需求。详情请 &lt;a href=&quot;http://blog.sina.com.cn/s/blog_56c35a550102dyl6.html&quot; title=&quot;成都出租车司机给我上的一课&quot;&gt;click me&lt;/a&gt; 。&lt;/p&gt;

&lt;h2&gt;小摘抄&lt;/h2&gt;

&lt;p&gt;首先，每次登陆微信，没在线这段时间的消息就会不停的弹出一大堆。用过微信群聊的朋友们应该会深有体会，尤其是群成员超过10个以上时，再加上有几个话唠，看完这些消息挺费劲。对于他们出租车司机来说，他们只需要及时聊天，并不需要看过去别人的聊天信息。&lt;/p&gt;

&lt;p&gt;其次，微信的通知挺烦，不停的响。他们这个行业，24小时都有人在工作，在聊天，形成打扰。我提醒他说微信有免打扰设置。他说他知道，可是那功能不好使。这个我也深有体会，确实不好使。有天半夜，我微信某个群组里的几个哥们聊的热火朝天，手机不停的在响，我睡觉很死，没听到，结果媳妇从隔壁房间冲过来关掉了我的手机，说打扰女儿睡觉了。我设置了微信的夜间免打扰功能，可惜这个功能确实很烂。&lt;/p&gt;

&lt;p&gt;第三，A产品设置几乎不用手操作，对司机很方便，而微信，和每个人聊天都要去按，去切换。另外，A产品有个功能是按下手机侧面的声音键就可以聊天，单手即可操作，且不需要眼睛去看；不像微信，需要去按产品界面上的按钮，一般需要双手操作，还需要眼睛去看。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>JQuery插件之tags的3D旋转球制作</title>
     <link href="http://webcraft.malei.tk/articles/3D-jquery"/>
     <updated>2012-08-18T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/3D-jquery</id>
     <content type="html">&lt;h2&gt;总述&lt;/h2&gt;

&lt;p&gt;这是学习JQuery插件制作的一次有意义的实践&lt;/p&gt;

&lt;h2&gt;声明&lt;/h2&gt;

&lt;p&gt;参考自 &lt;a href=&quot;http://www.miaov.com&quot;&gt;妙味课堂&lt;/a&gt; 的原生js，我的工作只不过是做成了JQuery插件。&lt;/p&gt;

&lt;h2&gt;对象级别的插件开发&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;(function ($) {
    $.fn.extend({
        pluginName:function(opt,callback){

        }
    });
})(jQuery);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function ($) {
    $.fn.pluginName=function(){

    }
})(jQuery);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面定义了一个jquery函数，形参是$，然后把实参jquery传进去，立即调用执行。好处：在写jquery插件时，也可使用$这个别名，而不会与prototype引起冲突。&lt;/p&gt;

&lt;h2&gt;先看一个五脏俱全的小例子&lt;/h2&gt;

&lt;h3&gt;插件代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*+++++++++++++++++声明 Start++++++++++++++
 *|                                       |
 *|   以下代码来自 ITEYE 的 gaojiewyh     |
 *|                                       |
 *+++++++++++++++++声明 End++++++++++++++++
 */
(function ($) {
    $.fn.hilight=function(options){
        debug(this);
        var opts=$.extend({},$.fn.hilight.defaults,options);
        return this.each(function(){
            var $this=$(this);
            $this.css({
                backgroundColor:opts.background,
                color:opts.foreground
            });
            var markup=$this.html();
            markup=$.fn.hilight.format(markup);
            $this.html(markup);
        });
    };
    //适当暴露一些函数
    $.fn.hilight.format=function(txt){
        return '&amp;lt;strong&amp;gt;'+txt+'&amp;lt;/strong&amp;gt;';
    }
    //暴露默认设置
    $.fn.hilight.defaults={
        foreground:'red',
        background:'yellow'
    };
    //保持私有函数的私有性
    function debug($obj){
        if(window.console &amp;amp;&amp;amp; window.console.log){
            window.console.log('hilight selection count:'+$obj.size());
        }
    }
})(jQuery);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;应用&lt;/h3&gt;

&lt;p&gt;1.采用默认设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&quot;.test&quot;).hilight();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.自定义设置一&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.fn.hilight.defaults.background='green';
$(&quot;.test&quot;).hilight();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.自定义设置二&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&quot;.test&quot;).hilight({
    foreground:'black',
    background:'gray'
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3D旋转球插件制作&lt;/h2&gt;

&lt;p&gt;提供“转速”和“旋转半径”的自定义&lt;/p&gt;

&lt;h3&gt;所需文档结构&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;threeDTags&quot;&amp;gt;
    &amp;lt;a href=&quot;#&quot;&amp;gt;&amp;lt;/a&amp;gt;
    &amp;lt;a href=&quot;#&quot;&amp;gt;&amp;lt;/a&amp;gt;
    &amp;lt;a href=&quot;#&quot;&amp;gt;&amp;lt;/a&amp;gt;
    &amp;lt;!-- ... n个 ... --&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;所需类库及样式表&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;jquery.min.js&lt;/li&gt;
&lt;li&gt;jquery.threeDTags.js&lt;/li&gt;
&lt;li&gt;threeDTags.css&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;ps:threeDTags.css并不存在，因为是个人应用，没有把相应的css独立出来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#threeDTags{
    position: relative;
    width: 270px;
    height: 270px;
}

#threeDTags a {
    position:absolute; 
    top:0px; 
    left:0px; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相对来说，这几句是比较重要的，想要什么效果，自己扩展。&lt;/p&gt;

&lt;h3&gt;应用&lt;/h3&gt;

&lt;p&gt;应用通以上三种用法，这里只写一种。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('threeDTags').threeDTags({
    radius:60,//半径
    tspeed:8//转速
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;FAQ&lt;/h2&gt;

&lt;h3&gt;如何获取鼠标相对于某个元素的位置?&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;document.getElementById('threeDTags').onmouseover=function (ev)
{
    var oEvent=window.event || ev;
    var mouseX,mouseY;

    mouseX=oEvent.clientX-($(this).offset().left-$(window).scrollLeft()+this.offsetWidth/2);
    mouseY=oEvent.clientY-($(this).offset().top-$(window).scrollTop()+this.offsetHeight/2);

    alert(mouseX+&quot; vs &quot;+mouseY);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了打破各家浏览器的浮动差异，以及 &lt;code&gt;document.getElementById('threeDTags').offsetLeft&lt;/code&gt; 相对于父元素(如果父元素 &lt;code&gt;position；relative&lt;/code&gt;)，而不是相对于整个文档的偏移，于是用了jquery类库。&lt;/p&gt;

&lt;p&gt;jquery中 &lt;code&gt;.offset()&lt;/code&gt; 为匹配的元素集合中获取第一个元素的当前坐标，相对于文档（document）。&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;第一次写插件，代码相对混乱，但是会不断优化的。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>仿 SAE 的收藏夹图标，做了一个 Pure CSS 的版本</title>
     <link href="http://webcraft.malei.tk/articles/sae-cloud-icon"/>
     <updated>2012-08-17T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/sae-cloud-icon</id>
     <content type="html">&lt;h2&gt;效果预览&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&quot;/about.html&quot; title=&quot;关于我&quot;&gt;About&lt;/a&gt;界面的 Feb. 2012 的 SAE&lt;/p&gt;

&lt;h2&gt;一个 span 搞定&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;span class='cloud-icon'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;添砖加瓦&lt;/h2&gt;

&lt;h3&gt;span 主体：底座&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;.cloud-icon{
    width: 266px;
    height: 115px;
    float:left;
    background:#555;
    border-radius: 60px;
    -moz-border-radius:60px;
    -webkit-border-radius: 60px;
    -ms-border-radius:60px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;右边突出比较大的部分&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;.cloud-icon::before{
    position:relative;
    content:'';
    left: 82px;
    top: -82px;
    width: 130px;
    height: 130px;
    float:left;
    background:#555;
    border-radius:65px;
    -moz-border-radius:65px;
    -webkit-border-radius: 65px;
    -ms-border-radius:65px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;左边突出比较小的部分&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;.cloud-icon::after{
    position:relative;
    content:'';
    left: -98px;
    top: -38px;
    width: 70px;
    height: 70px;
    float:left;
    background: #555;
    border-radius:35px;
    -moz-border-radius:35px;
    -webkit-border-radius: 35px;
    -ms-border-radius:35px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;云已完成，完整的显示，需要调父元素的 &lt;code&gt;padding&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;float&lt;/code&gt; 当该属性不等于none引起对象浮动时，对象将被视作块对象(&lt;code&gt;block-level&lt;/code&gt;)，即display属性等于block。也就是说，浮动对象的display特性将被忽略。 该属性可以被应用在非绝对定位的任何元素上。&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>制作图像 picture 的阴影显示效果</title>
     <link href="http://webcraft.malei.tk/articles/image-shadow"/>
     <updated>2012-08-17T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/image-shadow</id>
     <content type="html">&lt;h2&gt;效果预览&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/articles/imgShadow/imgShadow-1.png&quot; title=&quot;效果图&quot; alt=&quot;imgShadow&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;主要结构&lt;/h2&gt;

&lt;p&gt;主要是两层，外层的 &lt;code&gt;div&lt;/code&gt; 层主要是起 “相框” 的作用，里面的 &lt;code&gt;img&lt;/code&gt; 放图片。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;box-shadow&quot;&amp;gt;
    &amp;lt;img src=&quot;&quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;CSS渲染&lt;/h2&gt;

&lt;h3&gt;“相框” 的主架&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;“相框” 要紧紧地包裹图片 =&gt; &lt;code&gt;display:inline-block&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;伪对象的相对偏移 =&gt; &lt;code&gt;position: relative&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;CSS如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.box-shadow{
    position: relative;
    display:inline-block;
    z-index: 1;
    background: white;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;伪对象实现阴影效果&lt;/h3&gt;

&lt;p&gt;左右两片，绝对定位，效果实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.box-shadow::after,.box-shadow::before{
    z-index:-1;
    position:absolute;
    content:&quot;&quot;;
    bottom:15px;
    left:10px;
    width:50%;
    top:80%;
    max-width:300px;
    background:#999999;
    -webkit-box-shadow:0 15px 10px #999999;
    -moz-box-shadow:0 15px 10px #999999;
    box-shadow:0 15px 10px #999999;
    -webkit-transform:rotate(-2deg);
    -moz-transform:rotate(-2deg);
    -o-transform:rotate(-2deg);
    -ms-transform:rotate(-2deg);
    transform:rotate(-2deg);
}

.box-shadow::after{
    -webkit-transform:rotate(2deg);
    -moz-transform:rotate(2deg);
    -o-transform:rotate(2deg);
    -ms-transform:rotate(2deg);
    transform:rotate(2deg);
    right:10px;
    left:auto;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;注意 &lt;code&gt;transform:rotate(2deg)&lt;/code&gt; 这种小转角的应用&lt;/li&gt;
&lt;li&gt;层叠的 element 可以显示出不错的效果&lt;/li&gt;
&lt;li&gt;用更少的 element 干更多的事&lt;/li&gt;
&lt;li&gt;精简代码&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>容器透明，内容不透明，随机变色</title>
     <link href="http://webcraft.malei.tk/articles/random-color"/>
     <updated>2012-08-12T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/random-color</id>
     <content type="html">&lt;h2&gt;想法&lt;/h2&gt;

&lt;p&gt;看着demos界面，假的瀑布流布局有些单调，于是想随机给个背景颜色。开始没想到各种颜色的&lt;code&gt;真彩&lt;/code&gt;，冲击这么强烈，让人不舒服。于是就产生了&lt;code&gt;容器透明，内容不透明&lt;/code&gt;的想法。&lt;/p&gt;

&lt;h2&gt;步骤&lt;/h2&gt;

&lt;h3&gt;1.分配颜色&lt;/h3&gt;

&lt;p&gt;我们知道颜色正整数值的取值范围为：&lt;code&gt;0 - 255&lt;/code&gt;。除以5，来个均分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var colorBit = new Array(6);
colorBit[0] = &quot;255&quot;;
colorBit[1] = &quot;204&quot;;
colorBit[2] = &quot;153&quot;;
colorBit[3] = &quot;102&quot;;
colorBit[4] = &quot;51&quot;;
colorBit[5] = &quot;0&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2.颜色组合&lt;/h3&gt;

&lt;p&gt;red,green,blue三原色的不同组合，融合成了不同色彩。根据排列组合原理，从&lt;code&gt;6&lt;/code&gt;个数取出&lt;code&gt;3&lt;/code&gt;个，进行可重复的排列，有 &lt;code&gt;6&lt;/code&gt;的&lt;code&gt;3&lt;/code&gt;次方种情况，即：取&lt;code&gt;3&lt;/code&gt;次，每次有&lt;code&gt;6&lt;/code&gt;种选择，&lt;code&gt;6*6*6&lt;/code&gt;是也。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var colorArray=new Array();
for (var i = 0; i &amp;lt; 6; i++){
    for (var j = 0; j &amp;lt; 6; j++){
        for (var k = 0; k &amp;lt; 6; k++){
            colorArray.push(colorBit[i]+','+colorBit[j]+','+colorBit[k]);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3.上色(借助JQuery)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$('#waterFallContainer article').each(function(index,domEle){
    var randomColor=colorArray[Math.floor((colorArray.length)*Math.random())];
    $(domEle).css('backgroundColor','rgba('+randomColor+',0.1)');
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;小插曲&lt;/h2&gt;

&lt;p&gt;容器透明，内容不透明，有两种方法(来自&lt;code&gt;飘零雾雨&lt;/code&gt;的经验谈)：&lt;/p&gt;

&lt;h3&gt;1.方法一&lt;/h3&gt;

&lt;p&gt;原理是容器层与内容层并级，容器层设置透明度，内容层通过负&lt;code&gt;margin&lt;/code&gt;或者&lt;code&gt;position&lt;/code&gt;绝对定位等方式覆盖到容器层上&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.outer{width:200px;height:200px;background:#000;filter:alpha(opacity=20);opacity:.2;}
.inner{width:200px;height:200px;margin-top:-200px;}

&amp;lt;div class=&quot;outer&quot;&amp;gt;&amp;lt;!--我是透明的容器--&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;inner&quot;&amp;gt;我是不透明的内容&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2.方法二&lt;/h3&gt;

&lt;p&gt;高级浏览器直接使用rgba颜色值实现；IE浏览器在定义容器透明的同时，让子节点相对定位，也可达到效果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.outer{width:200px;height:200px;background:rgba(0,0,0,.2);background:#000\9;filter:alpha(opacity=20)\9;}
.outer .inner{position:relative\9;}

&amp;lt;div class=&quot;outer&quot;&amp;gt;
    &amp;lt;div class=&quot;inner&quot;&amp;gt;我是不透明的内容&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;追加&lt;/h2&gt;

&lt;p&gt;把随机的背景色改成了随机border&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>articlesLayout构建之右侧目录索引</title>
     <link href="http://webcraft.malei.tk/articles/articlesLayout-directory"/>
     <updated>2012-08-09T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/articlesLayout-directory</id>
     <content type="html">&lt;h2&gt;总述&lt;/h2&gt;

&lt;p&gt;就像前面说的一样，这种博客，一直是一个梦。因为所有的博客程序在编辑时，都不把博客的书写风格规范化。都只是按自己所想，随心所欲的在 &lt;code&gt;textarea&lt;/code&gt; 中添加，发布。&lt;/p&gt;

&lt;p&gt;事实上，在知道 &lt;code&gt;MarkDown&lt;/code&gt; 之前，也懒得把 &lt;code&gt;textarea&lt;/code&gt; 中的内容规范化，太费事。直到2012年的7月底，无意间看到了BeiYuu搭建在GitHub的博客，知道了 &lt;code&gt;jekyll + GitHub + MarkDown&lt;/code&gt; 的书写方式，加之这种目录索引，这正是我想要的。&lt;/p&gt;

&lt;p&gt;兴奋了几天，一心扑在上面，也要完成一款自己的 &lt;code&gt;jekyll&lt;/code&gt; 博客，其实对 &lt;code&gt;jekyll&lt;/code&gt; 早就有耳闻，但是只是停留在听说过的地步。后悔没有早一点打开 &lt;code&gt;jekyll&lt;/code&gt; 这扇门。&lt;/p&gt;

&lt;h2&gt;声明&lt;/h2&gt;

&lt;p&gt;在下面出现的某些算法思想、核心部分都是继承自BeiYuu。当然也有自己的想法杂烩其中，如不指明，均来自于BeiYuu。&lt;/p&gt;

&lt;h2&gt;界面构建&lt;/h2&gt;

&lt;h3&gt;总体布局&lt;/h3&gt;

&lt;p&gt;此界面主要分两栏，右栏是绝对定位，脱离正常文档流 &lt;code&gt;position:absolute&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;article&amp;gt;
    &amp;lt;!-- 文章内容 --&amp;gt;
&amp;lt;/article&amp;gt;
&amp;lt;aside id=&quot;menuIndex&quot; class=&quot;right&quot;&amp;gt;
    &amp;lt;!-- 目录索引 --&amp;gt;
&amp;lt;/aside&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;文章的详细信息头&lt;/h3&gt;

&lt;p&gt;这里并没有像BeiYuu那样每次的&lt;code&gt;h1&lt;/code&gt;标题都需自己手动书写，简化了一哈，把对 &lt;code&gt;page.title&lt;/code&gt; 等头部信息的处理，放在了 &lt;code&gt;layout&lt;/code&gt; 中，另外，加了不少其他信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;article-title&quot;&amp;gt;
    &amp;lt;h1&amp;gt;&amp;lt;a href=&quot;{{ page.url }}&quot;&amp;gt;{{ page.title }}&amp;lt;/a&amp;gt;&amp;lt;/h1&amp;gt;
    &amp;lt;div class=&quot;clearfix&quot;&amp;gt;
        &amp;lt;div class=&quot;article-post-time left&quot;&amp;gt;
            &amp;lt;span&amp;gt;&amp;amp;#8227;&amp;lt;/span&amp;gt;
            &amp;lt;time class=&quot;date&quot; pubdate=&quot;{{ page.date | date_to_utc | date: '%Y-%m-%d' }}&quot;&amp;gt;{{ page.date | date_to_utc | date: &quot;%Y-%m-%d&quot; }}&amp;lt;/time&amp;gt;
        &amp;lt;/div&amp;gt;
        {% if page.tags != empty %}
        &amp;lt;div class=&quot;article-tags right&quot;&amp;gt;
            &amp;lt;span class=&quot;pure-css-tag&quot;&amp;gt;&amp;amp;nbsp;&amp;lt;/span&amp;gt;
            &amp;lt;span class=&quot;pure-css-tag-behind left&quot;&amp;gt;
                &amp;lt;ul&amp;gt;
                    {% for tag in page.tags %} 
                    &amp;lt;li&amp;gt;
                        &amp;lt;a href=&quot;/tags.html#{{ tag }}&quot;&amp;gt;
                            {{ tag }}
                        &amp;lt;/a&amp;gt;
                        &amp;lt;span&amp;gt;
                            ,
                        &amp;lt;/span&amp;gt;
                    &amp;lt;/li&amp;gt;
                    {% endfor %}
                &amp;lt;/ul&amp;gt;
            &amp;lt;/span&amp;gt; 
        &amp;lt;/div&amp;gt;
        {% endif %}
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;生成目录&lt;/h2&gt;

&lt;p&gt;主要列表的是二级、三级标题。&lt;/p&gt;

&lt;h3&gt;收集信息&lt;/h3&gt;

&lt;p&gt;把文章中标题的内容“拿到”相应数组中，而 id 信息则同步生成出来，写入相应数组。有两条线：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;jquery取出的 &lt;code&gt;h2&lt;/code&gt; 、&lt;code&gt;h3&lt;/code&gt; 的index线；&lt;/li&gt;
&lt;li&gt;自建两个数组的index线，&lt;code&gt;h2&lt;/code&gt; 数组是顺次的不间断的从 &lt;code&gt;0&lt;/code&gt; 依次到 &lt;code&gt;n&lt;/code&gt;，&lt;code&gt;h3&lt;/code&gt; 数组是间断的，对应于相应 &lt;code&gt;h2&lt;/code&gt; 的index&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;下面代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var h2 = [],h3 = [],tmpl = '&amp;lt;ul&amp;gt;',h2index = 0;
$.each($('.article-div-content&amp;gt;h2,.article-div-content&amp;gt;h3'),function(index,item){
    if(item.tagName.toLowerCase() == 'h2'){
        var h2item = {};
        h2item.name = $(item).text();
        h2item.id = 'menuIndex'+index;
        h2.push(h2item);
        h2index++;
    }else{
        var h3item = {};
        h3item.name = $(item).text();
        h3item.id = 'menuIndex'+index;
        if(!h3[h2index-1]){
            h3[h2index-1] = [];
        }
        h3[h2index-1].push(h3item);
    }
    item.id = 'menuIndex' + index
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;生成目录串&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;tmpl += '&amp;lt;li class=&quot;h1&quot;&amp;gt;&amp;lt;a href=&quot;#&quot; data-top=&quot;0&quot;&amp;gt;'+$('.article-title&amp;gt;h1').text()+'&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;';           
for(var i=0;i&amp;lt;h2.length;i++){
    tmpl += '&amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot; data-id=&quot;'+h2[i].id+'&quot;&amp;gt;'+h2[i].name+'&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;';
    if(h3[i]){
        for(var j=0;j&amp;lt;h3[i].length;j++){
            tmpl += '&amp;lt;li class=&quot;h3&quot;&amp;gt;&amp;lt;a href=&quot;#&quot; data-id=&quot;'+h3[i][j].id+'&quot;&amp;gt;'+h3[i][j].name+'&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;';
        }
    }
}
tmpl += '&amp;lt;/ul&amp;gt;';
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;插入目录并赋事件&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Chocolate&lt;/code&gt; 为本博客的一个通用类库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var $scrollable = Chocolate.findScrollableElement('body','html');
$('#menuIndex').append($(tmpl)).delegate('a','click',function(e){
    e.preventDefault();
    var scrollNum = $(this).attr('data-top') || $('#'+$(this).attr('data-id')).offset().top;
    $scrollable.animate({ scrollTop: scrollNum-30 }, 400, 'swing');
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Chocolate 类 findScrollableElement&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;$scrollElement = $(el)&lt;/code&gt; 这个变量以 &lt;code&gt;$&lt;/code&gt; 开头，因为被赋予了一个 JQuery 对象，增强程序的可读性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;findScrollableElement : function(els) {
    for (var i = 0, argLength = arguments.length; i &amp;lt; argLength; i++) {
        var el = arguments[i],
        $scrollElement = $(el);
        var ss=el;
        if ($scrollElement.scrollTop() &amp;gt; 0) {
            return $scrollElement;
        } else {
            $scrollElement.scrollTop(1);
            var isScrollable = $scrollElement.scrollTop() &amp;gt; 0;
            $scrollElement.scrollTop(0);
            if (isScrollable) {
                return $scrollElement;
            }
        }
    }
    return [];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;JQuery 之 scrollTop()&lt;/h3&gt;

&lt;p&gt;“匹配的元素集合中获取第一个元素的滚动条的垂直位置”。&lt;/p&gt;

&lt;p&gt;垂直滚动位置等于浏览器可见区域以上的已经淡出我们视野的隐藏区域。如果滚动条是在最顶部，或者这个元素没有滚动条，那么这个数字是0。当此元素没有滚动条时 &lt;code&gt;scrollTop(value)&lt;/code&gt; 是不起作用的（包括 body,html,window）。理论上，应该只有 window 可滚动，但是，在浏览器有滚动条的情况下，经测试 firefox 和 ie 的可滚动元素为 html、window，而 webkit 内核的浏览器为 body、window。&lt;/p&gt;

&lt;p&gt;既然这样，为什么不直接用 window 呢？like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('#menuIndex').append($(tmpl)).delegate('a','click',function(e){
    e.preventDefault();
    var scrollNum = $(this).attr('data-top') || $('#'+$(this).attr('data-id')).offset().top;
    //window.scrollTo(0,scrollNum-30);
    // $(window).scrollTop(scrollNum-30);
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;两条注释语句，随便开一条，即可以点击时跳转到相应位置。原因是没有滚动效果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(window).animate({ scrollTop: scrollNum-30 }, 400, 'swing');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是没有效果的，window 并不是 dom 元素，而是 window 对象，animate 不起作用。当然我们可以用原生的 javascript 完成滚动效果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//TODO:
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;相应目录项高亮&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;scrollTop&lt;/code&gt;数组中，应该比 &lt;code&gt;$('#menuIndex li')&lt;/code&gt; 集合中 &lt;code&gt;li&lt;/code&gt; 的个数少一个，利用这种特殊关系，通过数值调整，很巧妙地实现了相应目录的高亮。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(window).load(function(){
    var scrollTop = [];
    $.each($('#menuIndex li a'),function(index,item){
        if(!$(item).attr('data-top')){
            var top = $('#'+$(item).attr('data-id')).offset().top;
            scrollTop.push(top);
            $(item).attr('data-top',top);
        }
    });
    $(window).bind('scroll',function(){
        var nowTop = $(window).scrollTop(),index,length = scrollTop.length;
        if(nowTop+60 &amp;gt; scrollTop[length-1]){
            index = length
        }else{
            for(var i=0;i&amp;lt;length;i++){
                if(nowTop+60 &amp;lt;= scrollTop[i]){
                    index = i
                    break;
                }
            }
        }
        $('#menuIndex li').removeClass('on')
        $('#menuIndex li').eq(index).addClass('on')
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;我的改善&lt;/h2&gt;

&lt;p&gt;其实上面的代码中，也有我的小改，不过核心的东西还是来自于 BeiYuu 。下面写一小段判断，很简单，使目录索引随着滚动，不断移动，不断出现在我们的视野中。当没有这一 &lt;code&gt;($(window).height()-60)&amp;gt;$('#menuIndex').height()&lt;/code&gt; 条件时，是很可怕的，一旦 &lt;code&gt;$('#menuIndex').height()&lt;/code&gt; 大于 &lt;code&gt;$(window).height()&lt;/code&gt; 了，滚动条会因为目录区域的溢出可无限往下滚动。之所以 &lt;code&gt;$(window).height()-60&lt;/code&gt; 减 60，是因为本博客的版权高度大概60像素，这样避免了版权区域与目录区域的重叠覆盖。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(window).bind(&quot;scroll&quot;, function(){
    var menuIndex_scrHeight = $(window).scrollTop(),menuIndex_topHeight;
    if(menuIndex_scrHeight &amp;gt; 140 &amp;amp;&amp;amp; ($(window).height()-60)&amp;gt;$('#menuIndex').height()) {
        menuIndex_topHeight = menuIndex_scrHeight-140;
        $('#menuIndex').animate({top: menuIndex_topHeight},10);
    } 
    else{
        $('#menuIndex').animate({top: 0},10);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果减去的 footer 高度很大，岂不是达不到想要的效果，上面这种方法不是很好，或者说很局限，很差，那你可以这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(window).bind(&quot;scroll&quot;, function(){
    var menuIndex_scrHeight = $(window).scrollTop(),menuIndex_topHeight;
    var footerOffsetTop=$('footer').offset().top;
    if(menuIndex_scrHeight &amp;gt; 140 &amp;amp;&amp;amp; menuIndex_scrHeight&amp;lt;(footerOffsetTop-$('#menuIndex').height()) &amp;amp;&amp;amp; $(window).height()&amp;gt;$('#menuIndex').height()) {
        menuIndex_topHeight = menuIndex_scrHeight-140;
        $('#menuIndex').animate({top: menuIndex_topHeight},10);
    } 
    else{
        $('#menuIndex').animate({top: 0},10);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;footerOffsetTop&lt;/code&gt; 这个高度只要保持取到“分栏容器”后的，第一个元素的 &lt;code&gt;.offset().top&lt;/code&gt; 即可&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;不写不知道，很多概念还很模糊，试着解释了一哈，很不到位，不过理解稍微加深了一些。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Demos界面的伪瀑布流布局的实现</title>
     <link href="http://webcraft.malei.tk/articles/water-fall-layout"/>
     <updated>2012-08-07T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/water-fall-layout</id>
     <content type="html">&lt;h2&gt;为什么叫伪瀑布流&lt;/h2&gt;

&lt;p&gt;因为并没有实现动态loading...，也没有用脚本去嗅探浏览器的宽度，以确定具体有几条瀑布。这是由博客的具体情况决定的，因为所有的demo都是慢慢生成的，所以这个Demos界面主要是做了个collection。写的比较死，主要针对本博客所写。&lt;/p&gt;

&lt;h2&gt;liquid脚本&lt;/h2&gt;

&lt;h3&gt;遍历所有demo&lt;/h3&gt;

&lt;p&gt;给每篇文章一个特定的&lt;code&gt;ID&lt;/code&gt;，我这里是从&lt;code&gt;1&lt;/code&gt;开始，即&lt;code&gt;demo-index-1&lt;/code&gt;，因为我在&lt;code&gt;demo-index-0&lt;/code&gt;中存放了所有demo数量的概览，这个总数将由&lt;code&gt;js&lt;/code&gt;获取，留待后用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% assign index = 0 %}
{% for post in site.categories.demos %}
{% capture index %}{{ index | plus:1 }}{% endcapture %}
{% capture demo_index %}demo-index-{{ index }}{% endcapture %}
    &amp;lt;article id=&quot;{{ demo_index }}&quot;&amp;gt;
            &amp;lt;div class=&quot;demo-title&quot;&amp;gt;
                &amp;lt;h3&amp;gt;&amp;lt;a href=&quot;{{ post.url }}&quot;&amp;gt;{{ post.title }}&amp;lt;/a&amp;gt;&amp;lt;/h3&amp;gt;
                &amp;lt;p&amp;gt;{{ post.description }}&amp;lt;/p&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;demo-time&quot;&amp;gt;
                &amp;lt;p&amp;gt;&amp;lt;span&amp;gt;&amp;amp;#8227;&amp;lt;/span&amp;gt;&amp;lt;time pubdate=&quot;{{ post.date | date: '%b %d, %Y' }}&quot;&amp;gt;{{ post.date | date: '%b %d, %Y' }}&amp;lt;/time&amp;gt;&amp;lt;/p&amp;gt;
            &amp;lt;/div&amp;gt;
    &amp;lt;/article&amp;gt;
{% endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;demo数量概览&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;article id=&quot;demo-index-0&quot;&amp;gt;
    {% capture list_size %}{{ site.categories.demos | size }}{% endcapture %}
    &amp;lt;h3&amp;gt;
        All demos:
        (&amp;lt;span&amp;gt;
            {{list_size}}
        &amp;lt;/span&amp;gt;)
    &amp;lt;/h3&amp;gt;         
&amp;lt;/article&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;给出瀑布流容器&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;waterFallContainer&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;生成瀑布&lt;/h2&gt;

&lt;p&gt;主要就是用&lt;code&gt;js&lt;/code&gt;操作&lt;code&gt;DOM&lt;/code&gt;树，把文档呈现成自己想要的样子。&lt;/p&gt;

&lt;h3&gt;首先声明一个静态类&lt;/h3&gt;

&lt;p&gt;这里声明了如下属性、方法。具体分了5条瀑布，下面分别介绍每个方法的作用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var waterFall = {
    container: $(&quot;#waterFallContainer&quot;),
    columnNumber: 5,
    columnWidth: 184,
    demoIndex: 0,
    loadFinish: false,
    demosNum: parseInt($('#demo-index-0 span').text())+1,
    create: function(){  },
    loadAllDemos: function() {  },
    loadSingleDemo: function(column) {  },
    init:function(){  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;生成空瀑布&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;create: function(){
    var start=0, spans = '';
    for (start; start &amp;lt; this.columnNumber; start++) {
        spans = spans + '&amp;lt;span id=&quot;waterFallColumn-'+ start +'&quot; class=&quot;waterFallColumns&quot; style=&quot;width:'+ this.columnWidth +'px;&quot;&amp;gt;'+ '&amp;lt;/span&amp;gt; ';
    }
    this.container.html(spans);
    return this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;填入内容&lt;/h3&gt;

&lt;p&gt;把所有的demo剪切到瀑布流容器中。首先，在剪切一个节点前，先判断是否所有demo都已加载完毕。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;loadSingleDemo: function(column) {

    if (this.demoIndex &amp;gt; this.demosNum) {
        this.loadFinish = true;
    }
    else{
        column.append($(&quot;#demo-index-&quot;+this.demoIndex));
        this.demoIndex += 1;
    }
    return this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其次，有了上述方法，就可以放心的加载了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;loadAllDemos: function() {
    var index=0;
    for(index;index&amp;lt;this.demosNum;index +=5){
        var start = 0;
        for (start; start &amp;lt; this.columnNumber; start++) {
            var eleColumn = $(&quot;#waterFallColumn-&quot; + start);
            if (eleColumn &amp;amp;&amp;amp; !this.loadFinish) {
                this.loadSingleDemo(eleColumn);
            }           
        }
    }
    return this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;初始化&lt;/h3&gt;

&lt;p&gt;每个方法都&lt;code&gt;return this;&lt;/code&gt;,这样就可以像下面连着写了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;init:function(){
    this.create().loadAllDemos();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;FAQ&lt;/h2&gt;

&lt;p&gt;这里我遇到了一个问题，纠结了半天也没解决。本来想着 &lt;code&gt;span&lt;/code&gt;的&lt;code&gt;display:inline-block&lt;/code&gt; 就可以能解决问题了，诡异的是&lt;code&gt;span&lt;/code&gt;之间总有5像素的间隔（ps:&lt;code&gt;span&lt;/code&gt;的&lt;code&gt;margin&lt;/code&gt;为&lt;code&gt;0&lt;/code&gt;），怎么也找不出是哪的猫腻。于是乎，&lt;code&gt;display:block;float:left;&lt;/code&gt;。纠结啊。&lt;/p&gt;
</content>
   </entry>
   
 
</feed>
