<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>WebCraft</title>
   <link href="http://webcraft.malei.tk/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://webcraft.malei.tk" rel="alternate" type="text/html" />
   <updated>2013-07-11T10:51:55+08:00</updated>
   <id>http://webcraft.malei.tk</id>
   <author>
     <name>Lei Ma</name>
     <email>leiman0311@gmail.com</email>
   </author>

   
   <entry>
     <title>维护一个开源项目的小建议</title>
     <link href="http://webcraft.malei.tk/articles/tips-for-maintaining-an-open-source-library"/>
     <updated>2013-05-14T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/tips-for-maintaining-an-open-source-library</id>
     <content type="html">&lt;p&gt;大约在五个月前我们团队通过Hacker News发布了我们自己的JavaScript库 &lt;a href=&quot;https://github.com/segmentio/analytics.js&quot;&gt;Analytics.js&lt;/a&gt;，在刚发布的几个小时内一只排名第一的好成绩，并且在一天里它的评分从最初的20星突破了1000星。从这件事上我们学到了非常多的管理开源项目的技巧。所以我想把其中一些有用的技巧分享给大家。&lt;/p&gt;

&lt;p&gt;起初，我们对管理一个开源项目一无所知。甚至我认为我们在pull之前没有任何merge别人代码的资格。所以我们不得不快速学习。&lt;/p&gt;

&lt;p&gt;从最初我们发布Analytics.js超过2000个星至今，非常多的人在开源社区做出了惊人的贡献。在此期间我们学会了很多关于如何保持高质量的pull以及如何为贡献者简化开发流程的技巧。&lt;/p&gt;

&lt;h2&gt;保持编码风格的统一&lt;/h2&gt;

&lt;p&gt;新的开发者将会从现有的代码库中学习如何为库增添新的功能，而这才是他们应该做的事情。所有的开发者都想按照代码库的规范去增加新的功能而不是他们自己的规范。你的主要工作就是使这种规范尽可能的简单。新的开发者将会从现有的代码库中学习如何为库增添新的功能，而这才是他们应该做的事情。所有的开发者都想按照代码库的规范去增加新的功能而不是他们自己的规范。作为一个开源项目的维护着主要工作就是使以上情况尽可能的简单。&lt;/p&gt;

&lt;p&gt;当你的分支代码和核心代码表意含糊不清时无数的麻烦就来了，如果你在两个不同的地方用两种不同的方式做同一件事情，开发者怎么知道哪一种方式才是推荐的呢？答案是：他们不知道。&lt;/p&gt;

&lt;p&gt;更糟糕的是由于你的编码风格不统一，开发者无从决定，那么也会编码不统一（按自己的偏好来）。&lt;/p&gt;

&lt;p&gt;解决这个问题你需要花费很多的时间规范代码风格。作为一个准则，你不应该尝试在一个简单的开源库中用两种不同的方式。如果你一定要改变风格，那一定要迅速的在全球都改变。否则新人将无法区分你之前代码和现有代码的约定。&lt;/p&gt;

&lt;p&gt;我们一开始用一种很差劲的方式处理这个问题，所有的代码在一个文件里面，函数没有一个良好的结构组织。（并且如果你检查我们的提交，就必须先理清代码）我们在设计代码规范统一上没有花时间，所以库里的代码编写风格混杂不堪。&lt;/p&gt;

&lt;p&gt;当pull代码的时候我们每个人都与别人的代码发生冲突，因为每个人都修改了同一个文件，并且在他们想要介入新函数的地方加入自己的功能函数&lt;/p&gt;

&lt;h2&gt;使用正确的方法，简单的方法&lt;/h2&gt;

&lt;p&gt;最初我们构建代码的方式，导致在合并pull requests的时候遇到了许多问题：换句话说，刚开始我们的代码就没有结构。我们做出的改善代码结构的比较大的改变之一是使用 &lt;a href=&quot;https://github.com/component/component&quot;&gt;Component&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://segment.io/blog/posts/2013-05-09-tips-for-maintaining-an-open-source-library/component.png&quot; alt=&quot;Component&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们喜欢 Component 因为它消除了编码风格不统一的问题，减少了代码库的规模。Component 使用 &lt;a href=&quot;http://zh.wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt;，所以我们只需要在我们需要的地方，引入我们需要的模块即可。所有的事情都简单明了，这就意味着我们的代码对于新人来说更容易跟进。这是代码库维护者的梦想。&lt;/p&gt;

&lt;p&gt;在进行切换期间，我们写了一堆自己的组件来替换已经附在全局对象 analytics 上的通用函数。现在，组件可以在库的任何地方很简单的包含进来和使用，pull requesters 只是默认使用他们。&lt;/p&gt;

&lt;p&gt;自从我们发布了正确的方法，并且使他更加清晰，pull request 的代码质量获得了显著提升。&lt;/p&gt;

&lt;p&gt;为了尽可能保持统一编码风格的延续，当有新的代码提交上来的时候，你必须积极主动。不要害怕给 pull request 的代码添加注释，即使看起来只是一处很小的更正，也不要害怕拒绝不必要的可能会搞乱你的 API 的 requests。&lt;/p&gt;

&lt;p&gt;必须牢记的是，同样要严格要求自己的代码。如果在添加新特性时，自己开小差，懒得统一编码风格，为什么项目的贡献者不可以呢？总之。你的代码越干净，对于新手来说就有越多的例子学习。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>ubuntu 禁用 thinkpad e430 触摸板</title>
     <link href="http://webcraft.malei.tk/articles/ubuntu-thinkpad-e430-disable-touchpad"/>
     <updated>2013-04-13T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/ubuntu-thinkpad-e430-disable-touchpad</id>
     <content type="html">&lt;h2&gt;请打开终端&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;ctrl + alt + t
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;输入&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;xinput
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;⎡ Virtual core pointer                        id=2    [master pointer  (3)]
⎜   ↳ Virtual core XTEST pointer                id=4    [slave  pointer  (2)]
⎜   ↳ ThinkPad USB Travel Mouse                 id=10   [slave  pointer  (2)]
⎜   //注意下面一行的id在后面的命令中要用
⎜   ↳ SynPS/2 Synaptics TouchPad                id=13   [slave  pointer  (2)]
⎜   ↳ TPPS/2 IBM TrackPoint                     id=15   [slave  pointer  (2)]
⎣ Virtual core keyboard                       id=3    [master keyboard (2)]
    ↳ Virtual core XTEST keyboard                 id=5    [slave  keyboard (3)]
    ↳ Power Button                                id=6    [slave  keyboard (3)]
    ↳ Video Bus                                   id=7    [slave  keyboard (3)]
    ↳ Video Bus                                   id=8    [slave  keyboard (3)]
    ↳ Power Button                                id=9    [slave  keyboard (3)]
    ↳ Integrated Camera                           id=11   [slave  keyboard (3)]
    ↳ AT Translated Set 2 keyboard                id=12   [slave  keyboard (3)]
    ↳ ThinkPad Extra Buttons                      id=14   [slave  keyboard (3)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;接下来&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;xinput list-props 13 | grep Enabled
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Device Enabled (137):   1   //说明是开启状态
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;最后&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;xinput set-prop 13 137 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O了，检查一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xinput list-props 13 | grep Enabled
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Device Enabled (137):   0
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>前端测试框架搭建</title>
     <link href="http://webcraft.malei.tk/articles/web-front-end-test"/>
     <updated>2013-04-11T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/web-front-end-test</id>
     <content type="html">&lt;h2&gt;要了解的列表&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yeoman.io/&quot;&gt;yeoman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://log4js.berlios.de/&quot;&gt;log4.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://karma-runner.github.io/&quot;&gt;karma&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://pivotal.github.io/jasmine/&quot;&gt;jasmine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://gruntjs.com/getting-started&quot;&gt;grunt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/twitter/bower&quot;&gt;bower&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;OptiPNG&lt;/li&gt;
&lt;li&gt;JPEGtran&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>ubuntu 12.10 x64 ATI 5650 安装显卡驱动</title>
     <link href="http://webcraft.malei.tk/articles/ubuntu-ati-driver"/>
     <updated>2013-03-30T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/ubuntu-ati-driver</id>
     <content type="html">&lt;h2&gt;开始&lt;/h2&gt;

&lt;p&gt;由于在安装显卡驱动方面走了不少弯路，也花费了不少时间，害怕了。。。，此篇笔记旨在加深了解，等时机成熟了再实践&lt;/p&gt;

&lt;h3&gt;几条小命令&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;lspci | grep VGA

lsb_release -a
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;结果&lt;/h2&gt;

&lt;p&gt;还没来得及安装，就...&lt;/p&gt;

&lt;p&gt;真的悲剧了,dell 小本近期衰老现象严重，先是换了一块硬盘，没用几天，就又出问题了，表示现已壮烈牺牲，仅此纪念&lt;/p&gt;

&lt;h2&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://support.amd.com/cn/gpudownload/linux/Pages/radeon_linux.aspx&quot;&gt;官方驱动下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wiki.cchtml.com/index.php/Category:Installation_Documentation&quot;&gt;非官方 ATI linux按装Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>wine 你懂的</title>
     <link href="http://webcraft.malei.tk/articles/ubuntu-wine"/>
     <updated>2013-03-06T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/ubuntu-wine</id>
     <content type="html">&lt;h2&gt;bug:=。=:solve&lt;/h2&gt;

&lt;p&gt;you know, my ubuntu =&gt; 12.10 64bit&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/articles/ubuntu-wine/wine.png&quot; title=&quot;wine logo&quot; alt=&quot;wine logo&quot; /&gt; Wine Cheers!&lt;/p&gt;

&lt;h3&gt;bug详情：&lt;/h3&gt;

&lt;p&gt;p11-kit: couldn't load module: /usr/lib/i386-linux-gnu/pkcs11/gnome-keyring-pkcs11.so: /usr/lib/i386-linux-gnu/pkcs11/gnome-keyring-pkcs11.so: 无法打开共享对象文件: 没有那个文件或目录&lt;/p&gt;

&lt;h3&gt;解决方案：&lt;/h3&gt;

&lt;p&gt;1) 安装 getlibs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget https://launchpadlibrarian.net/53907140/getlibs_2.06-0ubuntu1~ppa2_all.deb
sudo dpkg -i getlibs_2.06-0ubuntu1~ppa2_all.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2)安装 32bit 库:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo getlibs -p gnome-keyring:i386
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果遇到此错误:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Failed to download file http://mirrors.kernel.org/ubuntu/pool/main/g/gnome-keyring/gnome-keyring_3.4.1-4ubuntu1~precise1_i386.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请在这下载:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget https://launchpad.net/~gnome3-team/+archive/gnome3/+files/gnome-keyring_3.4.1-4ubuntu1~precise1_i386.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;getlibs -i &quot;path-of-the-file&quot;/gnome-keyring_3.4.1-4ubuntu1~precise1_i386.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果所给链接损坏，请在这搜：https://launchpad.net&lt;/p&gt;

&lt;p&gt;3) 生成符号链接:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mkdir -p /usr/lib/i386-linux-gnu/pkcs11/ 
sudo ln -s /usr/lib32/i386-linux-gnu/pkcs11/gnome-keyring-pkcs11.so /usr/lib/i386-linux-gnu/pkcs11/gnome-keyring-pkcs11.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O啦!&lt;/p&gt;

&lt;h3&gt;当遇到这个bug时&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;fixme:winediag:AUDDRV_GetAudioEndpoint Winepulse is not officially supported by the wine project
fixme:winediag:AUDDRV_GetAudioEndpoint For sound related feedback and support, please visit http://ubuntuforums.org/showthread.php?t=1960599
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bug中给了链接，照着链接中的做，可解&lt;/p&gt;

&lt;h2&gt;几个常用命令&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;winecfg
winefile
wine uninstaller
wine xxoo.exe
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;结论&lt;/h2&gt;

&lt;p&gt;wine 不如 virtualbox 安装的 xp 好用&lt;/p&gt;

&lt;h2&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://help.ubuntu.com/community/Wine&quot; title=&quot;Wine Documentation&quot;&gt;Wine Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://askubuntu.com/questions/127848/wine-cant-find-gnome-keyring-pkcs11-so&quot; title=&quot;Wine can't find gnome-keyring-pkcs11.so&quot;&gt;Wine can't find gnome-keyring-pkcs11.so&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://ubuntuforums.org/showthread.php?t=1960599&quot; title=&quot;winepulse&quot;&gt;Winepulse&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>传说中的 screen</title>
     <link href="http://webcraft.malei.tk/articles/screen-sh"/>
     <updated>2013-03-06T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/screen-sh</id>
     <content type="html">&lt;h2&gt;基本语法&lt;/h2&gt;

&lt;p&gt;Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;screen [-AmRvx -ls -wipe][-d &amp;lt;作业名称&amp;gt;][-h &amp;lt;行数&amp;gt;][-r &amp;lt;作业名称&amp;gt;][-s ][-S &amp;lt;作业名称&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;参数说明&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;-A              将所有的视窗都调整为目前终端机的大小。
-d &amp;lt;作业名称&amp;gt;       将指定的screen作业离线。
-h &amp;lt;行数&amp;gt; 　     指定视窗的缓冲区行数。
-m              即使目前已在作业中的screen作业，仍强制建立新的screen作业。
-r &amp;lt;作业名称&amp;gt;       恢复离线的screen作业。
-R              先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。
-s              指定建立新视窗时，所要执行的shell。
-S &amp;lt;作业名称&amp;gt;   指定screen作业的名称。
-v              显示版本信息。
-x              恢复之前离线的screen作业。
-ls或--list    显示目前所有的screen作业。
-wipe           检查目前所有的screen作业，并删除已经无法使用的screen作业。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;nohup vs screen&lt;/h3&gt;

&lt;p&gt;如果我们可以忽略SIGHUP信号，关掉窗口应该就不会影响程序的运行了。nohup命令可以达到这个目的，如果程序的标准输出/标准错误是终端，nohup默认将其重定向到nohup.out文件。值得注意的是nohup命令只是使得程序忽略SIGHUP信号，还需要使用标记&amp;amp;把它放在后台运行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nohup &amp;lt;command&amp;gt; [argument…] &amp;amp;

//我最常用nohup的地方就是开启 goagent 代理
$ !nohup //执行最近执行的一条 nohup 命令，我最近的一条通常都是 nohup python ~/programs/goagent/local/proxy.py &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然nohup很容易使用，但还是比较“简陋”的，对于简单的命令能够应付过来，对于复杂的需要人机交互的任务就麻烦了。&lt;/p&gt;

&lt;h2&gt;快捷键&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;C-a ?   显示所有键绑定信息 //貌似我的 ubuntu 这条没反应啊
C-a w   显示所有窗口列表
C-a C-a 切换到之前显示的窗口
C-a c   创建一个新的运行shell的窗口并切换到该窗口
C-a n   切换到下一个窗口
C-a p   切换到前一个窗口(与C-a n相对)
C-a 0..9    切换到窗口0..9
C-a a   发送 C-a 到当前窗口
C-a d   暂时断开screen会话
C-a k   杀掉当前窗口  =。=
C-a [   进入拷贝/回滚模式
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;一个小例子&lt;/h2&gt;

&lt;p&gt;你可以不中断screen窗口中程序的运行而暂时断开（detach）screen会话，并在随后时间重新连接（attach）该会话，重新控制各窗口中运行的程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ &amp;gt;screen.test
$ screen vi screen.test //作为测试，随便敲点东西，然后键入 C-a d
  [detached from 4804.pts-0.malei-Inspiron-N4010]
$ screen -ls
  There is a screen on:
    4804.pts-0.malei-Inspiron-N4010 (2013年03月06日 17时52分03秒) (Detached)
  1 Socket in /var/run/screen/S-malei.

$ screen -r 4804.pts-0.malei-Inspiron-N4010 //4804 [tab] 补全即可(进入我们断开的绘画继续工作) C-a d
  [detached from 4804.pts-0.malei-Inspiron-N4010]
$ screen -ls
  There is a screen on:
    4804.pts-0.malei-Inspiron-N4010 (2013年03月06日 17时52分04秒) (Detached)
  1 Socket in /var/run/screen/S-malei.

//发现时间，暂停了 =。= 有木有  =========&amp;gt; 靠，颜色高亮好混乱啊
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果screen的进程打开的比较多，为了方便识别不同的screen，可以加上 -S 参数，给每个screen不同的
名称 比如 &lt;code&gt;screen -S test&lt;/code&gt; ,进程里就会看到这个screen被标为 &lt;code&gt;test.pts-0.host&lt;/code&gt; ,而不是进程ID了。&lt;/p&gt;

&lt;h2&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.gnu.org/software/screen/manual/screen.html&quot; title=&quot;screen命令官方文档&quot;&gt;screen命令官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/mchina/archive/2013/01/30/2880680.html&quot; title=&quot;linux screen 命令详解&quot;&gt;linux screen 命令详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/l-cn-screen/&quot; title=&quot;使用 screen 管理你的远程会话&quot;&gt;使用 screen 管理你的远程会话&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>xrandr 命令小用</title>
     <link href="http://webcraft.malei.tk/articles/ubuntu-xrandr-sh"/>
     <updated>2013-03-04T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/ubuntu-xrandr-sh</id>
     <content type="html">&lt;h2&gt;外接设备一览&lt;/h2&gt;

&lt;p&gt;在终端输入 &lt;code&gt;xrandr&lt;/code&gt; ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LVDS connected (normal left inverted right x axis y axis)
   1366x768       60.0 +
   1360x768       60.0  
   1280x768       60.0  
   1280x720       60.0  
   1024x768       60.0  
   1024x600       60.0  
   800x600        60.0  
   800x480        60.0  
   640x480        60.0  
DFP1 disconnected (normal left inverted right x axis y axis)
CRT1 connected 1920x1080+0+0 (normal left inverted right x axis y axis) 510mm x 287mm
   1920x1080      60.0*+
   1680x1050      60.0  
   1400x1050      60.0  
   1600x900       60.0  
   1280x1024      75.0     60.0  
   1440x900       60.0  
   1280x960       75.0     60.0  
   1152x864       60.0     75.0  
   1280x768       75.0     60.0  
   1280x720       75.0     60.0  
   1024x768       75.0     60.0  
   1024x600       75.0     60.0  
   800x600        75.0     60.3  
   800x480        75.0     60.3  
   640x480        75.0     59.9 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LVDS 就是笔记本的显示器输出(Low Voltage Differential Signaling，是一种低压差分信号技术接口)
DTP1 就是笔记本的HDMI端口(High Definition Multimedia Interface，中文名称是高清晰多媒体接口)
CRT1 就是笔记本上的VGA端口(Video Graphics Array，即视频图形阵列) =。= CRT是一种使用阴极射线管(Cathode Ray Tube）的显示器
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;xrandr 命令常用方式如下：&lt;/h2&gt;

&lt;p&gt;打开外接显示器(最高分辨率)，与笔记本液晶屏幕显示同样内容（克隆）:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xrandr --output CRT1 --same-as LVDS --auto  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开外接显示器(分辨率为1024x768)，与笔记本液晶屏幕显示同样内容（克隆）:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xrandr --output CRT1 --same-as LVDS --mode 1024x768  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开外接显示器(最高分辨率)，设置为右侧扩展屏幕:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xrandr --output CRT1 --right-of LVDS --auto  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关闭外接显示器:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xrandr --output CRT1 --off  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开外接显示器，同时关闭笔记本液晶屏幕（只用外接显示器工作）:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xrandr --output CRT1 --auto --output LVDS --off  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关闭外接显示器，同时打开笔记本液晶屏幕 (只用笔记本液晶屏)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xrandr --output CRT1 --off --output LVDS --auto  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;小结&lt;/h2&gt;

&lt;p&gt;由于在图形界面配置总是报错，所以。。。；如果命令没达到你想要的效果重启一下就可以了，貌似这里有问题，待测试：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;先连VGA线，再开机&lt;/li&gt;
&lt;li&gt;先开机，再连VGA线&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;经测试，对于我这个悲催的 &lt;code&gt;A卡&lt;/code&gt; 来说，&lt;code&gt;先连VGA线，再开机&lt;/code&gt; 是个不错的选择.&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Drupal 主题开发</title>
     <link href="http://webcraft.malei.tk/articles/drupal-theme"/>
     <updated>2013-03-04T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/drupal-theme</id>
     <content type="html">&lt;h2&gt;Drupal的预处理函数&lt;/h2&gt;

&lt;p&gt;ads&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>菜鸟学习linux</title>
     <link href="http://webcraft.malei.tk/articles/linux-study"/>
     <updated>2013-03-02T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/linux-study</id>
     <content type="html">&lt;h2&gt;总述&lt;/h2&gt;

&lt;p&gt;昨天重装系统:64位ubuntu（为了便于开发，支持8G内存），在同事帮忙配置开发环境的时候，看着他们一路命令敲下来，真是酷啊，于是一冲动，卸载了原来的 win7 + ubuntu(32bit) 双系统，开始了纯正的 linux 之旅. 先坦白一下历经坎坷的 &lt;code&gt;dell&lt;/code&gt; 小本的血泪史:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2011年元旦，它拔山涉水，从石家庄的中山路来到了北二环&lt;/li&gt;
&lt;li&gt;由纯正的 win7 血统 =&gt; win7旗舰版(伪)&lt;/li&gt;
&lt;li&gt;=&gt; vmware 虚拟机上装着各种系统的杂乱&lt;/li&gt;
&lt;li&gt;=&gt; win7 + ubuntu的双系统&lt;/li&gt;
&lt;li&gt;(小插曲)大四上半学期快结束的时候:2011-12-09:跟我来到了帝都&lt;/li&gt;
&lt;li&gt;=&gt; 完全开源的世界 linux(ubuntu) =。= EOF;&lt;/li&gt;
&lt;li&gt;// 内存：2G =&gt; 2G * 2 =&gt; 4G * 2&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;听说《鸟哥的linux私房菜》不错，可以在闲的无聊的时候看一看...&lt;/p&gt;

&lt;h2&gt;KVM vs VirtualBox&lt;/h2&gt;

&lt;h3&gt;Deferences&lt;/h3&gt;

&lt;p&gt;vbox 是由 qemu 改写而成，包含大量 qemu 代码。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以使用于&quot;不支持&quot;虚拟化技术的cpu。&lt;/li&gt;
&lt;li&gt;值得说的一点：vbox 在图形方面比较好，能进行2D 3D加速。&lt;/li&gt;
&lt;li&gt;但cpu控制不理想（估计是因为图形支持的缘故）。&lt;/li&gt;
&lt;li&gt;操作上有独立的图形界面，易于上手。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;kvm(Kernel-based Virtual Machine) 是linux内核包含的东西，使用qemu作为上层管理（命令行）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;要求 cpu 必须支持虚拟化。&lt;/li&gt;
&lt;li&gt;性能：作为服务器很好，可是图形能力十分的差。即使放电影，图像也是像刷油漆一样，一层一层的。&lt;/li&gt;
&lt;li&gt;cpu使用率控制很好。&lt;/li&gt;
&lt;li&gt;控制上比较简洁，功能比较丰富：比如使用 “无敌功能” 所有更改指向内存，你的镜像永远保持干净。 “母镜像”功能让你拥有n个独立快照点。还有很多参数。另外，kvm作为内核级的虚拟机，刚开始发展关注的公司比较多——但是还没有达到商业应用的水平。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;总体而言：在支持 虚拟化 的情况下，vbox 和 kvm 的性能差不多，主要是面向对象不同：kvm使用于服务器，vbox使用于桌面应用。&lt;/p&gt;

&lt;p&gt;如果要看性能对比：&lt;a href=&quot;http://os.51cto.com/art/201203/324172.htm&quot; title=&quot;Ubuntu 11.10 Xen、KVM 和 VirtualBox 比拼&quot;&gt;Ubuntu 11.10 Xen、KVM 和 VirtualBox 比拼&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里详细学一下 KVM，官网有详细的教程 &lt;a href=&quot;http://wiki.ubuntu.org.cn/Kvm%E6%95%99%E7%A8%8B&quot; title=&quot;Kvm 教程&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Fix BUG&lt;/h3&gt;

&lt;p&gt;by the way,当安装 VirtualBox 增强功能时，报这个错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Failed to open the CD/DVD image /home/malei/.VirtualBox/VBoxGuestAdditions_4.1.18.iso.
The medium '/home/malei/.VirtualBox/VBoxGuestAdditions_4.1.18.iso' can't be used as the requested device type
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以这样解决：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install virtualbox-guest-additions
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;常用命令一览&lt;/h2&gt;

&lt;p&gt;他们很简单，但是初学者，你懂的&lt;/p&gt;

&lt;h3&gt;某端口被占用&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;sudo netstat -antup | grep &amp;lt;要查询的端口&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;example:&lt;/h4&gt;

&lt;p&gt;查找 &lt;code&gt;3306&lt;/code&gt; 端口被谁占用了:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo netstat -antup | grep 3306
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      4090/mysqld 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;4090&lt;/code&gt; 就是他的端口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kill 4090
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;杀掉他就行了&lt;/p&gt;

&lt;p&gt;如果不放心，在杀之前&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ps -ef | grep mysqld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;果然，是那个进程号，杀对了&lt;/p&gt;

&lt;h3&gt;对一个文件夹下的目录和文件分别赋权限&lt;/h3&gt;

&lt;h4&gt;shell 脚本&lt;/h4&gt;

&lt;p&gt;写一个脚本(给他可执行的权限)，命名为 chmod.sh  放在目的路径下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for a in $(find .)
do
    if [ -d &quot;$a&quot; ]
        then
            chmod 755 $a
        else
            chmod 644 $a
    fi
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后(貌似遇到文件或目录中有空格的 =。= 不行)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./chmod.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完事&lt;/p&gt;

&lt;h4&gt;避免麻烦，直接在 terminal 中敲命令&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;find . -type d -exec chmod 755 {} \;
find . -type f -exec chmod 644 {} \;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搞定&lt;/p&gt;

&lt;h2&gt;源&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;deb http://mirrors.163.com/ubuntu/ quantal main restricted  
deb-src http://mirrors.163.com/ubuntu/ quantal main restricted  
deb http://mirrors.163.com/ubuntu/ quantal-updates main restricted  
deb-src http://mirrors.163.com/ubuntu/ quantal-updates main restricted  
deb http://mirrors.163.com/ubuntu/ quantal universe  
deb-src http://mirrors.163.com/ubuntu/ quantal universe  
deb http://mirrors.163.com/ubuntu/ quantal-updates universe  
deb-src http://mirrors.163.com/ubuntu/ quantal-updates universe  
deb http://mirrors.163.com/ubuntu/ quantal multiverse  
deb-src http://mirrors.163.com/ubuntu/ quantal multiverse  
deb http://mirrors.163.com/ubuntu/ quantal-updates multiverse  
deb-src http://mirrors.163.com/ubuntu/ quantal-updates multiverse  
deb http://mirrors.163.com/ubuntu/ quantal-backports main restricted universe multiverse  
deb-src http://mirrors.163.com/ubuntu/ quantal-backports main restricted universe multiverse  
deb http://mirrors.163.com/ubuntu/ quantal-security main restricted  
deb-src http://mirrors.163.com/ubuntu/ quantal-security main restricted  
deb http://mirrors.163.com/ubuntu/ quantal-security universe  
deb-src http://mirrors.163.com/ubuntu/ quantal-security universe  
deb http://mirrors.163.com/ubuntu/ quantal-security multiverse  
deb-src http://mirrors.163.com/ubuntu/ quantal-security multiverse  
deb http://extras.ubuntu.com/ubuntu quantal main  
deb-src http://extras.ubuntu.com/ubuntu quantal main
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;结语&lt;/h2&gt;
</content>
   </entry>
   
   <entry>
     <title>从 (97 & ~32) == 65 //true 入手js的位操作符</title>
     <link href="http://webcraft.malei.tk/articles/js-bitwise-operators"/>
     <updated>2013-02-22T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/js-bitwise-operators</id>
     <content type="html">&lt;h2&gt;先来个列表&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;操作符     用法      描述
按位与     a &amp;amp; b     如果两个操作数对应位都是 1 的话则在该位返回 1。
按位或     a | b     如果两个操作数对应位都是 0 的话则在该位返回 0。
按位异或   a ^ b     如果两个操作数对应位只有一个 1 的话则在该位返回 1。
求反       ~ a       反转操作数的每一位。
左移       a &amp;lt;&amp;lt; b    将 a 的二进制形式左移 b 位。右面的空位补零。
算术右移   a &amp;gt;&amp;gt; b       将 a 的二进制形式右移 b 位。忽略被移出的位。
逻辑右移   a &amp;gt;&amp;gt;&amp;gt; b    将 a 的二进制形式右移 b 位。忽略被移出的位，左侧补入 0。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先知道一点：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;数据在内存中是以二进制形式存放的。数值是以补码表示的。一个正数的补码和其原码的形式相同。
而负数的补码方式是将其绝对值的二进制形式“按位求反再加1” 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;二元位操作符&lt;/h2&gt;

&lt;h3&gt;用作测试的函数&lt;/h3&gt;

&lt;p&gt;扔到console里直接用即可&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var hex10to2 = function (o){
    //鉴于parseInt('0101') 与 parseInt(0101) 的不同结果(纠结，各浏览器应该不同，待测试)，
    //在您输入的时候请直接输入8进制数时，请直接输入数字（0101）
    //测试用，所以先只支持整数

    if(parseInt(o)){
        return parseInt(o).toString(2);
    } else{
        console.log('参数不正确，正确的参数为：1.整数 2.合法字符串（如&quot;123&quot;,&quot;0123&quot;,&quot;0x123&quot;）');
    }   
}

//忽略符号处理
var hex2to10 = function(str){
    //TODO:判断是否只包括 1 , 0
    return parseInt(str,2);
}
//两个函数的合并作业待做
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;我还比较熟悉的： &lt;code&gt;&amp;amp;,|,^&lt;/code&gt; 三种，举例如下：&lt;/h3&gt;

&lt;p&gt;65 &amp;amp; 32 结果为 0&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1000001
 100000
-------
0000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;65 | 32 结果为 97&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1000001
 100000
-------
1100001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;65 ^ 32 结果为 97&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1000001
 100000
-------
1100001
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;另外~很少用，也不熟悉&lt;/h3&gt;

&lt;h4&gt;详细说明&lt;/h4&gt;

&lt;p&gt;取反运算符~对运算数按位取反，将运算数各位值由1变为0，或由0变为1.因为计算机中数值以带符号位二进制表示，所以取反后，最高位符号位发生变化。&lt;/p&gt;

&lt;p&gt;32按位取反后结果为（-33）。我们采用32的8位二进制形式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hex10to2(32) =&amp;gt; 100000 补全得：00100000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;00100000 按位取反为 11011111，这是一个补码形式，最高位为符号位。将该补码再求补（符号位保持不变，其他位按位取反，最后加1），得到10100001，该值是带符号的真值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hex2to10('100001'); //33
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加个负号得：-33&lt;/p&gt;

&lt;h4&gt;另外：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;97 &amp;amp; -33 //65
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将 -33（10100001）符号位保持不变，其他位按位取反，最后加1，为：11011111&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;01100001
11011111
--------
01000001

hex2to10('01000001'); //65
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正如你看到的，原码和补码是可逆的, 写成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;97 &amp;amp; ~32
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更一目了然一些，因为我只需要去掉从右向左数的第6个 1,那个1 =&gt; 2的（6-1）次方,所以 &lt;code&gt;&amp;amp;&lt;/code&gt; 一下 &lt;code&gt;~32&lt;/code&gt; 即可&lt;/p&gt;

&lt;h4&gt;位操作进行加减运算&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;... 64 32 16 8 4 2 1
...  7  6  5 4 3 2 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想让第x位变成 1，也就是加上 2 的 &lt;code&gt;x-1&lt;/code&gt; 次方（如果那位不是1的话）,令 y = 2 的 &lt;code&gt;x-1&lt;/code&gt; 次方&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x | y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想让第x位变成 0，也就是减去 2 的 &lt;code&gt;x-1&lt;/code&gt; 次方（如果那位不是0的话）,令 y = 2 的 &lt;code&gt;x-1&lt;/code&gt; 次方&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;amp; ~ y
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;有意思的实现&lt;/h3&gt;

&lt;h4&gt;手动大小写&lt;/h4&gt;

&lt;p&gt;因为javascript已经实现了（toUpperCase() and toLowerCase()）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function isString(value){return typeof value == 'string';}

var manualLowercase = function(s) {
    return isString(s)
            ? s.replace(/[A-Z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) | 32);})
            : s;
};
var manualUppercase = function(s) {
    return isString(s)
            ? s.replace(/[a-z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) &amp;amp; ~32);})
            : s;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;奇偶数判断&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;function isNumber(value){return typeof value == 'number';}

//利用 0 或 1 对 1 的 &amp;amp; 运算都是原数值，可得：
var isOdd = function(num){ //奇数
    if(isNumber(num)){
        return num &amp;amp; 1 ? true : false;
    } else{
        return false;
    }
}

var isEven = function(num){ //偶数           
    if(isNumber(num)){
        return num &amp;amp; 1 ? false : true;
    } else{
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;移位操作符&lt;/h2&gt;

&lt;p&gt;移位操作符需要两个操作数：第一个是要进行移位的数值，第二个指定要对第一个数移位的数目。移位的方向由使用的操作符决定。&lt;/p&gt;

&lt;p&gt;移位操作符将把两个操作符转换为 32 位整型数值，并返回与左操作数类型相同的结果。&lt;/p&gt;

&lt;h3&gt;&amp;lt;&amp;lt; (左移)&lt;/h3&gt;

&lt;p&gt;该操作符将把第一个操作数向左移若干位。移出的位将被忽略。右侧空位补零。
例如，9&amp;lt;&amp;lt;2 结果为 36，因为 1001 向左移两位变成 100100，这是 36。快捷算法:9 * (2的移位次方)&lt;/p&gt;

&lt;h3&gt;&gt;&gt; (算术右移)&lt;/h3&gt;

&lt;p&gt;该操作符将把第一个操作数向右移若干位。移出的位将被忽略。左侧的空位补上与原来最左面位相同的值。
例如，9&gt;&gt;2 结果为 2，因为 1001 右移两位变成 10，这是 2。。快捷算法:9 / (2的移位次方)&lt;/p&gt;

&lt;p&gt;反之，-9&gt;&gt;2 结果为 -3，因为要考虑到符号位。&lt;/p&gt;

&lt;p&gt;9在计算机中表示为(我们采用9的8位二进制形式)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;00001001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;则 -9，为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10001001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重复上面的算法：符号位保持不变，其他位按位取反，最后加1，得到 -9 在计算机中的表示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;11110111
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;算数右移两位 =&gt; 补1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;11111101
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重复补码算法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10000011
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到 -3&lt;/p&gt;

&lt;h3&gt;&gt;&gt;&gt; (逻辑右移)&lt;/h3&gt;

&lt;p&gt;该操作符将把第一个操作数向右移若干位。移出的位将被忽略。左侧的空位补零。
例如，19&gt;&gt;&gt;2 结果为 4，因为 10011 右移两位变成 100，这是 4。对于非负数，算术右移和逻辑右移结果相同。&lt;/p&gt;

&lt;p&gt;那么负数呢？&lt;/p&gt;

&lt;p&gt;-9&gt;&gt;2 结果为 ?&lt;/p&gt;

&lt;p&gt;9在计算机中表示为(我们采用9的8位二进制形式)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;00001001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;则 -9，为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;10001001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重复上面的算法：符号位保持不变，其他位按位取反，最后加1，得到 -9 在计算机中的表示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;11110111
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;逻辑右移两位 =&gt; 补0&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;00111101
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为变成正数了，所以不用重复补码算法了&lt;/p&gt;

&lt;p&gt;计算机采用的是32位二进制形式，所以&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0011...1101 //中间是30个1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到 1073741821&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hex10to2(1073741821) //111111111111111111111111111101
&quot;111111111111111111111111111101&quot;.length //30,略去了前面两个0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Reference&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.malei.tk/negative-number-binary&quot; title=&quot;原码，反码，补码&quot;&gt;原码，反码，补码&lt;/a&gt;&lt;/p&gt;
</content>
   </entry>
   
 
</feed>
