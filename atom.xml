<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>WebCraft</title>
   <link href="http://webcraft.malei.tk/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://webcraft.malei.tk" rel="alternate" type="text/html" />
   <updated>2013-07-31T11:17:49+08:00</updated>
   <id>http://webcraft.malei.tk</id>
   <author>
     <name>Lei Ma</name>
     <email>leiman0311@gmail.com</email>
   </author>

   
   <entry>
     <title>shell 之重定向</title>
     <link href="http://webcraft.malei.tk/articles/linux-study-shell-redirect"/>
     <updated>2013-07-31T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/linux-study-shell-redirect</id>
     <content type="html">&lt;h2&gt;总述&lt;/h2&gt;

&lt;p&gt;在前面的文章学习 &lt;a href=&quot;/articles/screen-sh/&quot;&gt;screen&lt;/a&gt; 时，已经用过 &lt;code&gt;nohup&lt;/code&gt; 。不过，像那么用，每次他都会写入默认的 nohup.out 文件中，并且每次都是叠加的，这么就造成一个可见的丑陋的文件无休止的增大，( ︶︿︶)_╭∩╮，那么就让他隐藏吧....&lt;/p&gt;

&lt;h2&gt;开始&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;nohup python /home/malei/programs/goagent/local/proxy.py &amp;gt; .nohup.out 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就好了，看不见那个令人不愉快的文件，且每次都是重写的，不会变得相当大了，︵(@￣︶￣@)︵。这种写法是 重定向标准输出和错误到同一个文件，详情，如下 ⟱&lt;/p&gt;

&lt;h2&gt;重定向标准输出和错误到同一个文件&lt;/h2&gt;

&lt;h3&gt;旧版 shell&lt;/h3&gt;

&lt;p&gt;可能有这种情况，我们希望捕捉一个命令的所有输出到一个文件。为了完成这个，我们 必须同时重定向标准输出和标准错误。有两种方法来完成任务。第一个，传统的方法， 在旧版本 shell 中也有效：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ls -l /bin/usr &amp;gt; ls-output.txt 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用这种方法，我们完成两个重定向。首先重定向标准输出到文件 ls-output.txt，然后 重定向文件描述符2（标准错误）到文件描述符1（标准输出）使用表示法 &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;注意重定向的顺序安排非常重要。标准错误的重定向必须总是出现在标准输出 重定向之后，要不然它不起作用。上面的例子，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;ls-output.txt 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重定向标准错误到文件 ls-output.txt，但是如果命令顺序改为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2&amp;gt;&amp;amp;1 &amp;gt;ls-output.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;则标准错误定向到屏幕。&lt;/p&gt;

&lt;h3&gt;新版 shell&lt;/h3&gt;

&lt;p&gt;现在的 bash 版本提供了第二种方法，更精简合理的方法来执行这种联合的重定向。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ls -l /bin/usr &amp;amp;&amp;gt; ls-output.txt 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子里面，我们使用单单一个表示法 &amp;amp;&gt; 来重定向标准输出和错误到文件 ls-output.txt。&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;入门级别的学习，Θ_Θ。比起 《鸟哥的 Linux 私房菜》，推荐下面这个简短轻快的读物，见 Reference。&lt;/p&gt;

&lt;h2&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://billie66.github.io/TLCL/book/zh/chap07.html&quot;&gt;The Linux Command Line&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>CSS 预处理器  LESS vs SASS</title>
     <link href="http://webcraft.malei.tk/articles/less-vs-sass"/>
     <updated>2013-07-30T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/less-vs-sass</id>
     <content type="html">&lt;h2&gt;总述&lt;/h2&gt;

&lt;h3&gt;SASS 的前世今生&lt;/h3&gt;

&lt;p&gt;Sass是是一种基于ruby编写的CSS预处理器，诞生于2007年，是最早也是最成熟的一款CSS预处理器语言，它可以使用变量、嵌套、混入、继承，运算，函数等功能，使得CSS的开发，变得简单清晰可维护，同时也大大节省了设计者的时间，提高了效率。Sass最后还是会编译出合法的CSS让浏览器使用，也就是说它本身的语法并不太容易让浏览器识别，因为它不是标准的CSS格式，在它的语法内部可以使用动态变量等，所以它更像一种极简单的动态语言。&lt;/p&gt;

&lt;p&gt;其实现在的Sass已经有了两套语法规则：一个依旧是用缩进作为分隔符来区分代码块的；另一套规则和CSS一样采用了大括号（｛｝）作为分隔符。后一种语法规则又名SCSS，在Sass3之后的版本都支持这种语法规则。&lt;/p&gt;

&lt;p&gt;sass虽然是最早的，但是一开始还是不太好用，而且使用缩进作为分隔符，不符合css使用大括号的习惯，所以less以后起之秀的身份轻松赢得了人心，后来sass借鉴于less的一些思想，改进了自己的设计，并有了scss，然后经过几个版本的更新，特别版本3.2.0做了些革命性的更新，以使它从其他几个编译处理器中脱颖而出。&lt;/p&gt;

&lt;p&gt;由上面可见，有时太激进了，用户是不领情的，“步子走大了，容易...”，你懂的。不过现在类 sass 的写法还挺受欢迎的：HAML，Slim，CoffeeScript，jade，styleus等...&lt;/p&gt;

&lt;h3&gt;ㄟ(￣▽￣ㄟ)&lt;/h3&gt;

&lt;p&gt;下面主要是自己在这段时间的使用中遇到的...&lt;/p&gt;

&lt;h2&gt;比较&lt;/h2&gt;

&lt;h3&gt;calc&lt;/h3&gt;

&lt;p&gt;less 中使用 calc 有 bug，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;calc(100% - 8px);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他会无情的给你解析成 92%，而在 sass 中没有问题。上一个比较 撮 的 demo：&lt;a href=&quot;http://codepen.io/malei0311/full/thAim&quot;&gt;click me&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;点击左下脚的 &lt;code&gt;edit&lt;/code&gt; ，把 calc() 法 中写在行内的 style calc，写入 less 中，靠，他变成 92%了&lt;/p&gt;

&lt;h3&gt;循环&lt;/h3&gt;

&lt;p&gt;虽然都能实现循环，但是 sass 使用起来更方便，例如 sass 中循环  for ，很简单，也方便。&lt;/p&gt;

&lt;h4&gt;sass demo:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;demo 地址: &lt;a href=&quot;/codepen/css-fibonacci/&quot;&gt;click me&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;demo 源码: &lt;a href=&quot;https://gist.github.com/malei0311/6099394&quot;&gt;click me&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;不怕慢也可以 codepen: &lt;a href=&quot;http://codepen.io/malei0311/pen/IsfLm&quot;&gt;click me&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;@for $i from 1 through $num {
  $temp: $i / 2 + 0px;

  .circle-#{$i} {  
    width: $temp;

    transform: rotate($i*137.5deg);
    &amp;amp;:after{
      animation-duration: 10s;
      animation-delay: 0.01s * $i;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;less demo:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;demo 地址: &lt;a href=&quot;/codepen/css-animation/&quot;&gt;click me&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;demo 源码: &lt;a href=&quot;https://gist.github.com/malei0311/6093738&quot;&gt;click me&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;不怕慢也可以 codepen: &lt;a href=&quot;http://codepen.io/malei0311/pen/eqyid&quot;&gt;click me&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;.loopingClass (@index,@father) when (@index =&amp;lt; @particles) {
  //这里需要一个恶心的 mixin + 关键字 when 实现一个条件判断，有木有 =。= !
  .father(@father) when (@father = demo1){
    .@{father} i:nth-child(@{index}) {

      @angle: @index / @particles * 360;      
      width: (@index * 14) + 0px;
      height: (@index * 14) + 0px;
      margin-top: -(@index * 14) / 2 + 0px;
      margin-left: -(@index * 14) / 2 + 0px;
      z-index: @particles - @index;
      transform:rotate( @angle + 0deg );

      transform-origin: 50% 50%;
      animation-delay: @index * (2s / @particles);
     }
  }

  .father(@father);
  .loopingClass(@index + 1, @father);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;条件判断&lt;/h3&gt;

&lt;p&gt;sass =&gt; if, less =&gt; when，下面两段代码，是 &lt;code&gt;上面循环&lt;/code&gt; 一节中 &lt;code&gt;less demo&lt;/code&gt; 的不同实现&lt;/p&gt;

&lt;p&gt;sass:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@mixin paintChild($father) {
  @for $i from 1 through $particles {
    .#{$father} i:nth-child(#{$i}) {
      @if $father == demo1 {
        $angle: $i / $particles * 360;

        width: ($i * 14) + px;
        height: ($i * 14) + px;
        margin-top: - ($i * 14) / 2 + px;
        margin-left: - ($i * 14) / 2 + px;
        z-index: $particles - $i;
        transform:rotate( #{$angle}deg );

        transform-origin: 50% 50%;
        animation-delay: $i * (2s / $particles);  
      } @else if $father == demo2 {
        ... // your code
      }
    }
  }
}

@include paintChild(demo1);
@include paintChild(demo2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;less:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.loopingClass (@index,@father) when (@index =&amp;lt; @particles) {
  //这里需要一个恶心的 mixin + 关键字 when 实现一个条件判断，有木有 =。= !
  .father(@father) when (@father = demo1){
    .@{father} i:nth-child(@{index}) {

      @angle: @index / @particles * 360;      
      width: (@index * 14) + 0px;
      height: (@index * 14) + 0px;
      margin-top: -(@index * 14) / 2 + 0px;
      margin-left: -(@index * 14) / 2 + 0px;
      z-index: @particles - @index;
      transform:rotate( @angle + 0deg );

      transform-origin: 50% 50%;
      animation-delay: @index * (2s / @particles);
     }
  }
  .father(@father) when (@father = demo2){
    ... // your code
  }
  .father(@father);
  .loopingClass(@index + 1, @father);
}

.loopingClass (1, demo1);
.loopingClass (1, demo2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;less会重复写 &lt;code&gt;.father(@father) when (...&lt;/code&gt; 有木有，另外，注意他们的单位计算方式，负号与后面有没有空格，与单位相加时怎么处理。&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;萝卜白菜，各有所爱，不过还是觉的 sass 在某些方面比较方便，另外 chrome 中还可以直接调试。其次，也要看项目历史原因、团队偏好，为了易维护性以及项目的一致性，怎么选，你懂的。&lt;/p&gt;

&lt;h2&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://css-tricks.com/sass-vs-less/&quot;&gt;sass-vs-less&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sass-lang.com/docs/yardoc/_index.html&quot;&gt;SASS官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>background-origin and background-clip</title>
     <link href="http://webcraft.malei.tk/articles/background-origin-and-clip"/>
     <updated>2013-07-15T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/background-origin-and-clip</id>
     <content type="html">&lt;h2&gt;简介&lt;/h2&gt;

&lt;h3&gt;&lt;a href=&quot;http://www.w3.org/TR/css3-background/#background-origin&quot;&gt;background-origin&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;设置或检索对象的背景图像计算background-position时的参考原点(位置)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;默认值：padding-box
padding-box：从padding区域（含padding）开始显示背景图像。
border-box：从border区域（含border）开始显示背景图像。
content-box：从content区域开始显示背景图像。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;a href=&quot;http://www.w3.org/TR/css3-background/#background-clip&quot;&gt;background-clip&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;指定对象的背景图像向外裁剪的区域。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;默认值：border-box
padding-box：从padding区域（不含padding）开始向外裁剪背景。
border-box：从border区域（不含border）开始向外裁剪背景。
content-box：从content区域开始向外裁剪背景。
text：从前景内容的形状（比如文字）作为裁剪区域向外裁剪，如此即可实现使用背景作为填充色之类的遮罩效果。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;CODE&lt;/h2&gt;

&lt;p&gt;请使用 chrome，点击右上角的 edit on codepen 可更改测试&lt;/p&gt;

&lt;h3&gt;background-origin&lt;/h3&gt;

&lt;p&gt;如果有 &lt;code&gt;background-attachment&lt;/code&gt; 是 fixed ，那么 &lt;code&gt;background-origin&lt;/code&gt;  不生效，并且这里是相对于 html（root）偏移，测试这一项，把本行的 &lt;code&gt;fixed&lt;/code&gt; 的注释去掉，还有把 &lt;code&gt;#demo&lt;/code&gt; 和 &lt;code&gt;body&lt;/code&gt; 的 &lt;code&gt;margin&lt;/code&gt; 置成 &lt;code&gt;0&lt;/code&gt; ，效果明显。详细原因参见：http://www.w3.org/TR/CSS21/visudet.html#containing-block-details&lt;/p&gt;

&lt;pre class=&quot;codepen&quot; data-height=&quot;300&quot; data-type=&quot;result&quot; data-href=&quot;GBxzl&quot; data-user=&quot;malei0311&quot; data-safe=&quot;true&quot;&gt;&lt;code&gt;&lt;/code&gt;&lt;a href=&quot;http://codepen.io/malei0311/pen/GBxzl&quot;&gt;Check out this Pen!&lt;/a&gt;&lt;/pre&gt;


&lt;script async src=&quot;http://codepen.io/assets/embed/ei.js&quot;&gt;&lt;/script&gt;


&lt;h3&gt;background-clip&lt;/h3&gt;

&lt;pre class=&quot;codepen&quot; data-height=&quot;300&quot; data-type=&quot;result&quot; data-href=&quot;tibDo&quot; data-user=&quot;malei0311&quot; data-safe=&quot;true&quot;&gt;&lt;code&gt;&lt;/code&gt;&lt;a href=&quot;http://codepen.io/malei0311/pen/tibDo&quot;&gt;Check out this Pen!&lt;/a&gt;&lt;/pre&gt;


&lt;script async src=&quot;http://codepen.io/assets/embed/ei.js&quot;&gt;&lt;/script&gt;


&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;如果你不想让背景从边界泄漏，以下代码还是很有用的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;background-clip: padding-box;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细请参见：&lt;a href=&quot;http://tumble.sneak.co.nz/post/928998513/fixing-the-background-bleed&quot;&gt;Fixing the background 'bleed'&lt;/a&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>维护一个开源项目的小建议</title>
     <link href="http://webcraft.malei.tk/articles/tips-for-maintaining-an-open-source-library"/>
     <updated>2013-05-14T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/tips-for-maintaining-an-open-source-library</id>
     <content type="html">&lt;p&gt;大约在五个月前我们团队通过Hacker News发布了我们自己的JavaScript库 &lt;a href=&quot;https://github.com/segmentio/analytics.js&quot;&gt;Analytics.js&lt;/a&gt;，在刚发布的几个小时内一只排名第一的好成绩，并且在一天里它的评分从最初的20星突破了1000星。从这件事上我们学到了非常多的管理开源项目的技巧。所以我想把其中一些有用的技巧分享给大家。&lt;/p&gt;

&lt;p&gt;起初，我们对管理一个开源项目一无所知。甚至我认为我们在pull之前没有任何merge别人代码的资格。所以我们不得不快速学习。&lt;/p&gt;

&lt;p&gt;从最初我们发布Analytics.js超过2000个星至今，非常多的人在开源社区做出了惊人的贡献。在此期间我们学会了很多关于如何保持高质量的pull以及如何为贡献者简化开发流程的技巧。&lt;/p&gt;

&lt;h2&gt;保持编码风格的统一&lt;/h2&gt;

&lt;p&gt;新的开发者将会从现有的代码库中学习如何为库增添新的功能，而这才是他们应该做的事情。所有的开发者都想按照代码库的规范去增加新的功能而不是他们自己的规范。你的主要工作就是使这种规范尽可能的简单。新的开发者将会从现有的代码库中学习如何为库增添新的功能，而这才是他们应该做的事情。所有的开发者都想按照代码库的规范去增加新的功能而不是他们自己的规范。作为一个开源项目的维护着主要工作就是使以上情况尽可能的简单。&lt;/p&gt;

&lt;p&gt;当你的分支代码和核心代码表意含糊不清时无数的麻烦就来了，如果你在两个不同的地方用两种不同的方式做同一件事情，开发者怎么知道哪一种方式才是推荐的呢？答案是：他们不知道。&lt;/p&gt;

&lt;p&gt;更糟糕的是由于你的编码风格不统一，开发者无从决定，那么也会编码不统一（按自己的偏好来）。&lt;/p&gt;

&lt;p&gt;解决这个问题你需要花费很多的时间规范代码风格。作为一个准则，你不应该尝试在一个简单的开源库中用两种不同的方式。如果你一定要改变风格，那一定要迅速的在全球都改变。否则新人将无法区分你之前代码和现有代码的约定。&lt;/p&gt;

&lt;p&gt;我们一开始用一种很差劲的方式处理这个问题，所有的代码在一个文件里面，函数没有一个良好的结构组织。（并且如果你检查我们的提交，就必须先理清代码）我们在设计代码规范统一上没有花时间，所以库里的代码编写风格混杂不堪。&lt;/p&gt;

&lt;p&gt;当pull代码的时候我们每个人都与别人的代码发生冲突，因为每个人都修改了同一个文件，并且在他们想要介入新函数的地方加入自己的功能函数&lt;/p&gt;

&lt;h2&gt;使用正确的方法，简单的方法&lt;/h2&gt;

&lt;p&gt;最初我们构建代码的方式，导致在合并pull requests的时候遇到了许多问题：换句话说，刚开始我们的代码就没有结构。我们做出的改善代码结构的比较大的改变之一是使用 &lt;a href=&quot;https://github.com/component/component&quot;&gt;Component&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://segment.io/blog/posts/2013-05-09-tips-for-maintaining-an-open-source-library/component.png&quot; alt=&quot;Component&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们喜欢 Component 因为它消除了编码风格不统一的问题，减少了代码库的规模。Component 使用 &lt;a href=&quot;http://zh.wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt;，所以我们只需要在我们需要的地方，引入我们需要的模块即可。所有的事情都简单明了，这就意味着我们的代码对于新人来说更容易跟进。这是代码库维护者的梦想。&lt;/p&gt;

&lt;p&gt;在进行切换期间，我们写了一堆自己的组件来替换已经附在全局对象 analytics 上的通用函数。现在，组件可以在库的任何地方很简单的包含进来和使用，pull requesters 只是默认使用他们。&lt;/p&gt;

&lt;p&gt;自从我们发布了正确的方法，并且使他更加清晰，pull request 的代码质量获得了显著提升。&lt;/p&gt;

&lt;p&gt;为了尽可能保持统一编码风格的延续，当有新的代码提交上来的时候，你必须积极主动。不要害怕给 pull request 的代码添加注释，即使看起来只是一处很小的更正，也不要害怕拒绝不必要的可能会搞乱你的 API 的 requests。&lt;/p&gt;

&lt;p&gt;必须牢记的是，同样要严格要求自己的代码。如果在添加新特性时，自己开小差，懒得统一编码风格，为什么项目的贡献者不可以呢？总之。你的代码越干净，对于新手来说就有越多的例子学习。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>ubuntu 禁用 thinkpad e430 触摸板</title>
     <link href="http://webcraft.malei.tk/articles/ubuntu-thinkpad-e430-disable-touchpad"/>
     <updated>2013-04-13T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/ubuntu-thinkpad-e430-disable-touchpad</id>
     <content type="html">&lt;h2&gt;请打开终端&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;ctrl + alt + t
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;输入&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;xinput
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;⎡ Virtual core pointer                        id=2    [master pointer  (3)]
⎜   ↳ Virtual core XTEST pointer                id=4    [slave  pointer  (2)]
⎜   ↳ ThinkPad USB Travel Mouse                 id=10   [slave  pointer  (2)]
⎜   //注意下面一行的id在后面的命令中要用
⎜   ↳ SynPS/2 Synaptics TouchPad                id=13   [slave  pointer  (2)]
⎜   ↳ TPPS/2 IBM TrackPoint                     id=15   [slave  pointer  (2)]
⎣ Virtual core keyboard                       id=3    [master keyboard (2)]
    ↳ Virtual core XTEST keyboard                 id=5    [slave  keyboard (3)]
    ↳ Power Button                                id=6    [slave  keyboard (3)]
    ↳ Video Bus                                   id=7    [slave  keyboard (3)]
    ↳ Video Bus                                   id=8    [slave  keyboard (3)]
    ↳ Power Button                                id=9    [slave  keyboard (3)]
    ↳ Integrated Camera                           id=11   [slave  keyboard (3)]
    ↳ AT Translated Set 2 keyboard                id=12   [slave  keyboard (3)]
    ↳ ThinkPad Extra Buttons                      id=14   [slave  keyboard (3)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;接下来&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;xinput list-props 13 | grep Enabled
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Device Enabled (137):   1   //说明是开启状态
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;最后&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;xinput set-prop 13 137 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O了，检查一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xinput list-props 13 | grep Enabled
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Device Enabled (137):   0
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>前端测试框架搭建</title>
     <link href="http://webcraft.malei.tk/articles/web-front-end-test"/>
     <updated>2013-04-11T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/web-front-end-test</id>
     <content type="html">&lt;h2&gt;要了解的列表&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yeoman.io/&quot;&gt;yeoman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://log4js.berlios.de/&quot;&gt;log4.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://karma-runner.github.io/&quot;&gt;karma&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://pivotal.github.io/jasmine/&quot;&gt;jasmine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://gruntjs.com/getting-started&quot;&gt;grunt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/twitter/bower&quot;&gt;bower&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;OptiPNG&lt;/li&gt;
&lt;li&gt;JPEGtran&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>ubuntu 12.10 x64 ATI 5650 安装显卡驱动</title>
     <link href="http://webcraft.malei.tk/articles/ubuntu-ati-driver"/>
     <updated>2013-03-30T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/ubuntu-ati-driver</id>
     <content type="html">&lt;h2&gt;开始&lt;/h2&gt;

&lt;p&gt;由于在安装显卡驱动方面走了不少弯路，也花费了不少时间，害怕了。。。，此篇笔记旨在加深了解，等时机成熟了再实践&lt;/p&gt;

&lt;h3&gt;几条小命令&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;lspci | grep VGA

lsb_release -a
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;结果&lt;/h2&gt;

&lt;p&gt;还没来得及安装，就...&lt;/p&gt;

&lt;p&gt;真的悲剧了,dell 小本近期衰老现象严重，先是换了一块硬盘，没用几天，就又出问题了，表示现已壮烈牺牲，仅此纪念&lt;/p&gt;

&lt;h2&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://support.amd.com/cn/gpudownload/linux/Pages/radeon_linux.aspx&quot;&gt;官方驱动下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wiki.cchtml.com/index.php/Category:Installation_Documentation&quot;&gt;非官方 ATI linux按装Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>wine 你懂的</title>
     <link href="http://webcraft.malei.tk/articles/ubuntu-wine"/>
     <updated>2013-03-06T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/ubuntu-wine</id>
     <content type="html">&lt;h2&gt;bug:=。=:solve&lt;/h2&gt;

&lt;p&gt;you know, my ubuntu =&gt; 12.10 64bit&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/articles/ubuntu-wine/wine.png&quot; title=&quot;wine logo&quot; alt=&quot;wine logo&quot; /&gt; Wine Cheers!&lt;/p&gt;

&lt;h3&gt;bug详情：&lt;/h3&gt;

&lt;p&gt;p11-kit: couldn't load module: /usr/lib/i386-linux-gnu/pkcs11/gnome-keyring-pkcs11.so: /usr/lib/i386-linux-gnu/pkcs11/gnome-keyring-pkcs11.so: 无法打开共享对象文件: 没有那个文件或目录&lt;/p&gt;

&lt;h3&gt;解决方案：&lt;/h3&gt;

&lt;p&gt;1) 安装 getlibs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget https://launchpadlibrarian.net/53907140/getlibs_2.06-0ubuntu1~ppa2_all.deb
sudo dpkg -i getlibs_2.06-0ubuntu1~ppa2_all.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2)安装 32bit 库:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo getlibs -p gnome-keyring:i386
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果遇到此错误:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Failed to download file http://mirrors.kernel.org/ubuntu/pool/main/g/gnome-keyring/gnome-keyring_3.4.1-4ubuntu1~precise1_i386.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请在这下载:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget https://launchpad.net/~gnome3-team/+archive/gnome3/+files/gnome-keyring_3.4.1-4ubuntu1~precise1_i386.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;getlibs -i &quot;path-of-the-file&quot;/gnome-keyring_3.4.1-4ubuntu1~precise1_i386.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果所给链接损坏，请在这搜：https://launchpad.net&lt;/p&gt;

&lt;p&gt;3) 生成符号链接:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mkdir -p /usr/lib/i386-linux-gnu/pkcs11/ 
sudo ln -s /usr/lib32/i386-linux-gnu/pkcs11/gnome-keyring-pkcs11.so /usr/lib/i386-linux-gnu/pkcs11/gnome-keyring-pkcs11.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O啦!&lt;/p&gt;

&lt;h3&gt;当遇到这个bug时&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;fixme:winediag:AUDDRV_GetAudioEndpoint Winepulse is not officially supported by the wine project
fixme:winediag:AUDDRV_GetAudioEndpoint For sound related feedback and support, please visit http://ubuntuforums.org/showthread.php?t=1960599
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bug中给了链接，照着链接中的做，可解&lt;/p&gt;

&lt;h2&gt;几个常用命令&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;winecfg
winefile
wine uninstaller
wine xxoo.exe
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;结论&lt;/h2&gt;

&lt;p&gt;wine 不如 virtualbox 安装的 xp 好用&lt;/p&gt;

&lt;h2&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://help.ubuntu.com/community/Wine&quot; title=&quot;Wine Documentation&quot;&gt;Wine Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://askubuntu.com/questions/127848/wine-cant-find-gnome-keyring-pkcs11-so&quot; title=&quot;Wine can't find gnome-keyring-pkcs11.so&quot;&gt;Wine can't find gnome-keyring-pkcs11.so&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://ubuntuforums.org/showthread.php?t=1960599&quot; title=&quot;winepulse&quot;&gt;Winepulse&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>传说中的 screen</title>
     <link href="http://webcraft.malei.tk/articles/screen-sh"/>
     <updated>2013-03-06T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/screen-sh</id>
     <content type="html">&lt;h2&gt;基本语法&lt;/h2&gt;

&lt;p&gt;Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;screen [-AmRvx -ls -wipe][-d &amp;lt;作业名称&amp;gt;][-h &amp;lt;行数&amp;gt;][-r &amp;lt;作业名称&amp;gt;][-s ][-S &amp;lt;作业名称&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;参数说明&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;-A              将所有的视窗都调整为目前终端机的大小。
-d &amp;lt;作业名称&amp;gt;       将指定的screen作业离线。
-h &amp;lt;行数&amp;gt; 　     指定视窗的缓冲区行数。
-m              即使目前已在作业中的screen作业，仍强制建立新的screen作业。
-r &amp;lt;作业名称&amp;gt;       恢复离线的screen作业。
-R              先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。
-s              指定建立新视窗时，所要执行的shell。
-S &amp;lt;作业名称&amp;gt;   指定screen作业的名称。
-v              显示版本信息。
-x              恢复之前离线的screen作业。
-ls或--list    显示目前所有的screen作业。
-wipe           检查目前所有的screen作业，并删除已经无法使用的screen作业。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;nohup vs screen&lt;/h3&gt;

&lt;p&gt;如果我们可以忽略SIGHUP信号，关掉窗口应该就不会影响程序的运行了。nohup命令可以达到这个目的，如果程序的标准输出/标准错误是终端，nohup默认将其重定向到nohup.out文件。值得注意的是nohup命令只是使得程序忽略SIGHUP信号，还需要使用标记&amp;amp;把它放在后台运行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nohup &amp;lt;command&amp;gt; [argument…] &amp;amp;

//我最常用nohup的地方就是开启 goagent 代理
$ !nohup //执行最近执行的一条 nohup 命令，我最近的一条通常都是 nohup python ~/programs/goagent/local/proxy.py &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然nohup很容易使用，但还是比较“简陋”的，对于简单的命令能够应付过来，对于复杂的需要人机交互的任务就麻烦了。&lt;/p&gt;

&lt;h2&gt;快捷键&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;C-a ?   显示所有键绑定信息 //貌似我的 ubuntu 这条没反应啊
C-a w   显示所有窗口列表
C-a C-a 切换到之前显示的窗口
C-a c   创建一个新的运行shell的窗口并切换到该窗口
C-a n   切换到下一个窗口
C-a p   切换到前一个窗口(与C-a n相对)
C-a 0..9    切换到窗口0..9
C-a a   发送 C-a 到当前窗口
C-a d   暂时断开screen会话
C-a k   杀掉当前窗口  =。=
C-a [   进入拷贝/回滚模式
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;一个小例子&lt;/h2&gt;

&lt;p&gt;你可以不中断screen窗口中程序的运行而暂时断开（detach）screen会话，并在随后时间重新连接（attach）该会话，重新控制各窗口中运行的程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ &amp;gt;screen.test
$ screen vi screen.test //作为测试，随便敲点东西，然后键入 C-a d
  [detached from 4804.pts-0.malei-Inspiron-N4010]
$ screen -ls
  There is a screen on:
    4804.pts-0.malei-Inspiron-N4010 (2013年03月06日 17时52分03秒) (Detached)
  1 Socket in /var/run/screen/S-malei.

$ screen -r 4804.pts-0.malei-Inspiron-N4010 //4804 [tab] 补全即可(进入我们断开的绘画继续工作) C-a d
  [detached from 4804.pts-0.malei-Inspiron-N4010]
$ screen -ls
  There is a screen on:
    4804.pts-0.malei-Inspiron-N4010 (2013年03月06日 17时52分04秒) (Detached)
  1 Socket in /var/run/screen/S-malei.

//发现时间，暂停了 =。= 有木有  =========&amp;gt; 靠，颜色高亮好混乱啊
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果screen的进程打开的比较多，为了方便识别不同的screen，可以加上 -S 参数，给每个screen不同的
名称 比如 &lt;code&gt;screen -S test&lt;/code&gt; ,进程里就会看到这个screen被标为 &lt;code&gt;test.pts-0.host&lt;/code&gt; ,而不是进程ID了。&lt;/p&gt;

&lt;h2&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.gnu.org/software/screen/manual/screen.html&quot; title=&quot;screen命令官方文档&quot;&gt;screen命令官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/mchina/archive/2013/01/30/2880680.html&quot; title=&quot;linux screen 命令详解&quot;&gt;linux screen 命令详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/l-cn-screen/&quot; title=&quot;使用 screen 管理你的远程会话&quot;&gt;使用 screen 管理你的远程会话&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>xrandr 命令小用</title>
     <link href="http://webcraft.malei.tk/articles/ubuntu-xrandr-sh"/>
     <updated>2013-03-04T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/ubuntu-xrandr-sh</id>
     <content type="html">&lt;h2&gt;外接设备一览&lt;/h2&gt;

&lt;p&gt;在终端输入 &lt;code&gt;xrandr&lt;/code&gt; ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LVDS connected (normal left inverted right x axis y axis)
   1366x768       60.0 +
   1360x768       60.0  
   1280x768       60.0  
   1280x720       60.0  
   1024x768       60.0  
   1024x600       60.0  
   800x600        60.0  
   800x480        60.0  
   640x480        60.0  
DFP1 disconnected (normal left inverted right x axis y axis)
CRT1 connected 1920x1080+0+0 (normal left inverted right x axis y axis) 510mm x 287mm
   1920x1080      60.0*+
   1680x1050      60.0  
   1400x1050      60.0  
   1600x900       60.0  
   1280x1024      75.0     60.0  
   1440x900       60.0  
   1280x960       75.0     60.0  
   1152x864       60.0     75.0  
   1280x768       75.0     60.0  
   1280x720       75.0     60.0  
   1024x768       75.0     60.0  
   1024x600       75.0     60.0  
   800x600        75.0     60.3  
   800x480        75.0     60.3  
   640x480        75.0     59.9 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LVDS 就是笔记本的显示器输出(Low Voltage Differential Signaling，是一种低压差分信号技术接口)
DTP1 就是笔记本的HDMI端口(High Definition Multimedia Interface，中文名称是高清晰多媒体接口)
CRT1 就是笔记本上的VGA端口(Video Graphics Array，即视频图形阵列) =。= CRT是一种使用阴极射线管(Cathode Ray Tube）的显示器
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;xrandr 命令常用方式如下：&lt;/h2&gt;

&lt;p&gt;打开外接显示器(最高分辨率)，与笔记本液晶屏幕显示同样内容（克隆）:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xrandr --output CRT1 --same-as LVDS --auto  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开外接显示器(分辨率为1024x768)，与笔记本液晶屏幕显示同样内容（克隆）:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xrandr --output CRT1 --same-as LVDS --mode 1024x768  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开外接显示器(最高分辨率)，设置为右侧扩展屏幕:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xrandr --output CRT1 --right-of LVDS --auto  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关闭外接显示器:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xrandr --output CRT1 --off  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开外接显示器，同时关闭笔记本液晶屏幕（只用外接显示器工作）:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xrandr --output CRT1 --auto --output LVDS --off  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关闭外接显示器，同时打开笔记本液晶屏幕 (只用笔记本液晶屏)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xrandr --output CRT1 --off --output LVDS --auto  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;小结&lt;/h2&gt;

&lt;p&gt;由于在图形界面配置总是报错，所以。。。；如果命令没达到你想要的效果重启一下就可以了，貌似这里有问题，待测试：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;先连VGA线，再开机&lt;/li&gt;
&lt;li&gt;先开机，再连VGA线&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;经测试，对于我这个悲催的 &lt;code&gt;A卡&lt;/code&gt; 来说，&lt;code&gt;先连VGA线，再开机&lt;/code&gt; 是个不错的选择.&lt;/p&gt;
</content>
   </entry>
   
 
</feed>
