<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>WebCraft</title>
   <link href="http://webcraft.malei.tk/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://webcraft.malei.tk" rel="alternate" type="text/html" />
   <updated>2012-09-10T19:17:10+08:00</updated>
   <id>http://webcraft.malei.tk</id>
   <author>
     <name>Lei Ma</name>
     <email>leiman0311@gmail.com</email>
   </author>

   
   <entry>
     <title>sublime text 2 插件使用</title>
     <link href="http://webcraft.malei.tk/articles/sublime-text-2"/>
     <updated>2012-09-10T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/sublime-text-2</id>
     <content type="html">&lt;p&gt;//TODO:sfgsf&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>该怎么做？</title>
     <link href="http://webcraft.malei.tk/articles/how-to-do"/>
     <updated>2012-08-29T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/how-to-do</id>
     <content type="html">&lt;h2&gt;总述&lt;/h2&gt;

&lt;p&gt;越来越发现自己是榆木脑袋，没有新意，从来没有做过产品，只是
&lt;a href=&quot;http://blog.sina.com.cn/s/blog_56c35a550102dyl6.html&quot; title=&quot;成都出租车司机给我上的一课&quot;&gt;成都出租车司机给我上的一课&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;//TODO:&lt;/h2&gt;

&lt;p&gt;首先，每次登陆微信，没在线这段时间的消息就会不停的弹出一大堆。用过微信群聊的朋友们应该会深有体会，尤其是群成员超过10个以上时，再加上有几个话唠，看完这些消息挺费劲。对于他们出租车司机来说，他们只需要及时聊天，并不需要看过去别人的聊天信息。&lt;/p&gt;

&lt;p&gt;其次，微信的通知挺烦，不停的响。他们这个行业，24小时都有人在工作，在聊天，形成打扰。我提醒他说微信有免打扰设置。他说他知道，可是那功能不好使。这个我也深有体会，确实不好使。有天半夜，我微信某个群组里的几个哥们聊的热火朝天，手机不停的在响，我睡觉很死，没听到，结果媳妇从隔壁房间冲过来关掉了我的手机，说打扰女儿睡觉了。我设置了微信的夜间免打扰功能，可惜这个功能确实很烂。&lt;/p&gt;

&lt;p&gt;第三，A产品设置几乎不用手操作，对司机很方便，而微信，和每个人聊天都要去按，去切换。另外，A产品有个功能是按下手机侧面的声音键就可以聊天，单手即可操作，且不需要眼睛去看；不像微信，需要去按产品界面上的按钮，一般需要双手操作，还需要眼睛去看。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>JQuery插件之tags的3D旋转球制作</title>
     <link href="http://webcraft.malei.tk/articles/3D-jquery"/>
     <updated>2012-08-18T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/3D-jquery</id>
     <content type="html">&lt;h2&gt;总述&lt;/h2&gt;

&lt;p&gt;这是学习JQuery插件制作的一次有意义的实践&lt;/p&gt;

&lt;h2&gt;声明&lt;/h2&gt;

&lt;p&gt;参考自 &lt;a href=&quot;http://www.miaov.com&quot;&gt;妙味课堂&lt;/a&gt; 的原生js，我的工作只不过是做成了JQuery插件。&lt;/p&gt;

&lt;h2&gt;对象级别的插件开发&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;(function ($) {
    $.fn.extend({
        pluginName:function(opt,callback){

        }
    });
})(jQuery);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function ($) {
    $.fn.pluginName=function(){

    }
})(jQuery);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面定义了一个jquery函数，形参是$，然后把实参jquery传进去，立即调用执行。好处：在写jquery插件时，也可使用$这个别名，而不会与prototype引起冲突。&lt;/p&gt;

&lt;h2&gt;先看一个五脏俱全的小例子&lt;/h2&gt;

&lt;h3&gt;插件代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/*+++++++++++++++++声明 Start++++++++++++++
 *|                                       |
 *|   以下代码来自 ITEYE 的 gaojiewyh     |
 *|                                       |
 *+++++++++++++++++声明 End++++++++++++++++
 */
(function ($) {
    $.fn.hilight=function(options){
        debug(this);
        var opts=$.extend({},$.fn.hilight.defaults,options);
        return this.each(function(){
            var $this=$(this);
            $this.css({
                backgroundColor:opts.background,
                color:opts.foreground
            });
            var markup=$this.html();
            markup=$.fn.hilight.format(markup);
            $this.html(markup);
        });
    };
    //适当暴露一些函数
    $.fn.hilight.format=function(txt){
        return '&amp;lt;strong&amp;gt;'+txt+'&amp;lt;/strong&amp;gt;';
    }
    //暴露默认设置
    $.fn.hilight.defaults={
        foreground:'red',
        background:'yellow'
    };
    //保持私有函数的私有性
    function debug($obj){
        if(window.console &amp;amp;&amp;amp; window.console.log){
            window.console.log('hilight selection count:'+$obj.size());
        }
    }
})(jQuery);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;应用&lt;/h3&gt;

&lt;p&gt;1.采用默认设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&quot;.test&quot;).hilight();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.自定义设置一&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.fn.hilight.defaults.background='green';
$(&quot;.test&quot;).hilight();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.自定义设置二&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&quot;.test&quot;).hilight({
    foreground:'black',
    background:'gray'
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3D旋转球插件制作&lt;/h2&gt;

&lt;p&gt;提供“转速”和“旋转半径”的自定义&lt;/p&gt;

&lt;h3&gt;所需文档结构&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;threeDTags&quot;&amp;gt;
    &amp;lt;a href=&quot;#&quot;&amp;gt;&amp;lt;/a&amp;gt;
    &amp;lt;a href=&quot;#&quot;&amp;gt;&amp;lt;/a&amp;gt;
    &amp;lt;a href=&quot;#&quot;&amp;gt;&amp;lt;/a&amp;gt;
    &amp;lt;!-- ... n个 ... --&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;所需类库及样式表&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;jquery.min.js&lt;/li&gt;
&lt;li&gt;jquery.threeDTags.js&lt;/li&gt;
&lt;li&gt;threeDTags.css&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;ps:threeDTags.css并不存在，因为是个人应用，没有把相应的css独立出来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#threeDTags{
    position: relative;
    width: 270px;
    height: 270px;
}

#threeDTags a {
    position:absolute; 
    top:0px; 
    left:0px; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相对来说，这几句是比较重要的，想要什么效果，自己扩展。&lt;/p&gt;

&lt;h3&gt;应用&lt;/h3&gt;

&lt;p&gt;应用通以上三种用法，这里只写一种。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('threeDTags').threeDTags({
    radius:60,//半径
    tspeed:8//转速
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;FAQ&lt;/h2&gt;

&lt;h3&gt;如何获取鼠标相对于某个元素的位置?&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;document.getElementById('threeDTags').onmouseover=function (ev)
{
    var oEvent=window.event || ev;
    var mouseX,mouseY;

    mouseX=oEvent.clientX-($(this).offset().left-$(window).scrollLeft()+this.offsetWidth/2);
    mouseY=oEvent.clientY-($(this).offset().top-$(window).scrollTop()+this.offsetHeight/2);

    alert(mouseX+&quot; vs &quot;+mouseY);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了打破各家浏览器的浮动差异，以及 &lt;code&gt;document.getElementById('threeDTags').offsetLeft&lt;/code&gt; 相对于父元素(如果父元素 &lt;code&gt;position；relative&lt;/code&gt;)，而不是相对于整个文档的偏移，于是用了jquery类库。&lt;/p&gt;

&lt;p&gt;jquery中 &lt;code&gt;.offset()&lt;/code&gt; 为匹配的元素集合中获取第一个元素的当前坐标，相对于文档（document）。&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;第一次写插件，代码相对混乱，但是会不断优化的。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>仿 SAE 的收藏夹图标，做了一个 Pure CSS 的版本</title>
     <link href="http://webcraft.malei.tk/articles/sae-cloud-icon"/>
     <updated>2012-08-17T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/sae-cloud-icon</id>
     <content type="html">&lt;h2&gt;效果预览&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&quot;/about.html&quot; title=&quot;关于我&quot;&gt;About&lt;/a&gt;界面的 Feb. 2012 的 SAE&lt;/p&gt;

&lt;h2&gt;一个 span 搞定&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;span class='cloud-icon'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;添砖加瓦&lt;/h2&gt;

&lt;h3&gt;span 主体：底座&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;.cloud-icon{
    width: 266px;
    height: 115px;
    float:left;
    background:#555;
    border-radius: 60px;
    -moz-border-radius:60px;
    -webkit-border-radius: 60px;
    -ms-border-radius:60px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;右边突出比较大的部分&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;.cloud-icon::before{
    position:relative;
    content:'';
    left: 82px;
    top: -82px;
    width: 130px;
    height: 130px;
    float:left;
    background:#555;
    border-radius:65px;
    -moz-border-radius:65px;
    -webkit-border-radius: 65px;
    -ms-border-radius:65px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;左边突出比较小的部分&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;.cloud-icon::after{
    position:relative;
    content:'';
    left: -98px;
    top: -38px;
    width: 70px;
    height: 70px;
    float:left;
    background: #555;
    border-radius:35px;
    -moz-border-radius:35px;
    -webkit-border-radius: 35px;
    -ms-border-radius:35px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;云已完成，完整的显示，需要调父元素的 &lt;code&gt;padding&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;float&lt;/code&gt; 当该属性不等于none引起对象浮动时，对象将被视作块对象(&lt;code&gt;block-level&lt;/code&gt;)，即display属性等于block。也就是说，浮动对象的display特性将被忽略。 该属性可以被应用在非绝对定位的任何元素上。&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>制作图像 picture 的阴影显示效果</title>
     <link href="http://webcraft.malei.tk/articles/image-shadow"/>
     <updated>2012-08-17T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/image-shadow</id>
     <content type="html">&lt;h2&gt;效果预览&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/articles/css/imgShadow-1.png&quot; alt=&quot;imgShadow&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;主要结构&lt;/h2&gt;

&lt;p&gt;主要是两层，外层的 &lt;code&gt;div&lt;/code&gt; 层主要是起 “相框” 的作用，里面的 &lt;code&gt;img&lt;/code&gt; 放图片。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;box-shadow&quot;&amp;gt;
    &amp;lt;img src=&quot;&quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;CSS渲染&lt;/h2&gt;

&lt;h3&gt;“相框” 的主架&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;“相框” 要紧紧地包裹图片 =&gt; &lt;code&gt;display:inline-block&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;伪对象的相对偏移 =&gt; &lt;code&gt;position: relative&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;CSS如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.box-shadow{
    position: relative;
    display:inline-block;
    z-index: 1;
    background: white;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;伪对象实现阴影效果&lt;/h3&gt;

&lt;p&gt;左右两片，绝对定位，效果实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.box-shadow::after,.box-shadow::before{
    z-index:-1;
    position:absolute;
    content:&quot;&quot;;
    bottom:15px;
    left:10px;
    width:50%;
    top:80%;
    max-width:300px;
    background:#999999;
    -webkit-box-shadow:0 15px 10px #999999;
    -moz-box-shadow:0 15px 10px #999999;
    box-shadow:0 15px 10px #999999;
    -webkit-transform:rotate(-2deg);
    -moz-transform:rotate(-2deg);
    -o-transform:rotate(-2deg);
    -ms-transform:rotate(-2deg);
    transform:rotate(-2deg);
}

.box-shadow::after{
    -webkit-transform:rotate(2deg);
    -moz-transform:rotate(2deg);
    -o-transform:rotate(2deg);
    -ms-transform:rotate(2deg);
    transform:rotate(2deg);
    right:10px;
    left:auto;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;注意 &lt;code&gt;transform:rotate(2deg)&lt;/code&gt; 这种小转角的应用&lt;/li&gt;
&lt;li&gt;层叠的 element 可以显示出不错的效果&lt;/li&gt;
&lt;li&gt;用更少的 element 干更多的事&lt;/li&gt;
&lt;li&gt;精简代码&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>容器透明，内容不透明，随机变色</title>
     <link href="http://webcraft.malei.tk/articles/random-color"/>
     <updated>2012-08-12T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/random-color</id>
     <content type="html">&lt;h2&gt;想法&lt;/h2&gt;

&lt;p&gt;看着demos界面，假的瀑布流布局有些单调，于是想随机给个背景颜色。开始没想到各种颜色的&lt;code&gt;真彩&lt;/code&gt;，冲击这么强烈，让人不舒服。于是就产生了&lt;code&gt;容器透明，内容不透明&lt;/code&gt;的想法。&lt;/p&gt;

&lt;h2&gt;步骤&lt;/h2&gt;

&lt;h3&gt;1.分配颜色&lt;/h3&gt;

&lt;p&gt;我们知道颜色正整数值的取值范围为：&lt;code&gt;0 - 255&lt;/code&gt;。除以5，来个均分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var colorBit = new Array(6);
colorBit[0] = &quot;255&quot;;
colorBit[1] = &quot;204&quot;;
colorBit[2] = &quot;153&quot;;
colorBit[3] = &quot;102&quot;;
colorBit[4] = &quot;51&quot;;
colorBit[5] = &quot;0&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2.颜色组合&lt;/h3&gt;

&lt;p&gt;red,green,blue三原色的不同组合，融合成了不同色彩。根据排列组合原理，从&lt;code&gt;6&lt;/code&gt;个数取出&lt;code&gt;3&lt;/code&gt;个，进行可重复的排列，有 &lt;code&gt;6&lt;/code&gt;的&lt;code&gt;3&lt;/code&gt;次方种情况，即：取&lt;code&gt;3&lt;/code&gt;次，每次有&lt;code&gt;6&lt;/code&gt;种选择，&lt;code&gt;6*6*6&lt;/code&gt;是也。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var colorArray=new Array();
for (var i = 0; i &amp;lt; 6; i++){
    for (var j = 0; j &amp;lt; 6; j++){
        for (var k = 0; k &amp;lt; 6; k++){
            colorArray.push(colorBit[i]+','+colorBit[j]+','+colorBit[k]);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3.上色(借助JQuery)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$('#waterFallContainer article').each(function(index,domEle){
    var randomColor=colorArray[Math.floor((colorArray.length)*Math.random())];
    $(domEle).css('backgroundColor','rgba('+randomColor+',0.1)');
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;小插曲&lt;/h2&gt;

&lt;p&gt;容器透明，内容不透明，有两种方法(来自&lt;code&gt;飘零雾雨&lt;/code&gt;的经验谈)：&lt;/p&gt;

&lt;h3&gt;1.方法一&lt;/h3&gt;

&lt;p&gt;原理是容器层与内容层并级，容器层设置透明度，内容层通过负&lt;code&gt;margin&lt;/code&gt;或者&lt;code&gt;position&lt;/code&gt;绝对定位等方式覆盖到容器层上&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.outer{width:200px;height:200px;background:#000;filter:alpha(opacity=20);opacity:.2;}
.inner{width:200px;height:200px;margin-top:-200px;}

&amp;lt;div class=&quot;outer&quot;&amp;gt;&amp;lt;!--我是透明的容器--&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;inner&quot;&amp;gt;我是不透明的内容&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2.方法二&lt;/h3&gt;

&lt;p&gt;高级浏览器直接使用rgba颜色值实现；IE浏览器在定义容器透明的同时，让子节点相对定位，也可达到效果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.outer{width:200px;height:200px;background:rgba(0,0,0,.2);background:#000\9;filter:alpha(opacity=20)\9;}
.outer .inner{position:relative\9;}

&amp;lt;div class=&quot;outer&quot;&amp;gt;
    &amp;lt;div class=&quot;inner&quot;&amp;gt;我是不透明的内容&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;追加&lt;/h2&gt;

&lt;p&gt;把随机的背景色改成了随机border&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>articlesLayout构建之右侧目录索引</title>
     <link href="http://webcraft.malei.tk/articles/articlesLayout-directory"/>
     <updated>2012-08-09T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/articlesLayout-directory</id>
     <content type="html">&lt;h2&gt;总述&lt;/h2&gt;

&lt;p&gt;就像前面说的一样，这种博客，一直是一个梦。因为所有的博客程序在编辑时，都不把博客的书写风格规范化。都只是按自己所想，随心所欲的在 &lt;code&gt;textarea&lt;/code&gt; 中添加，发布。&lt;/p&gt;

&lt;p&gt;事实上，在知道 &lt;code&gt;MarkDown&lt;/code&gt; 之前，也懒得把 &lt;code&gt;textarea&lt;/code&gt; 中的内容规范化，太费事。直到2012年的7月底，无意间看到了BeiYuu搭建在GitHub的博客，知道了 &lt;code&gt;jekyll + GitHub + MarkDown&lt;/code&gt; 的书写方式，加之这种目录索引，这正是我想要的。&lt;/p&gt;

&lt;p&gt;兴奋了几天，一心扑在上面，也要完成一款自己的 &lt;code&gt;jekyll&lt;/code&gt; 博客，其实对 &lt;code&gt;jekyll&lt;/code&gt; 早就有耳闻，但是只是停留在听说过的地步。后悔没有早一点打开 &lt;code&gt;jekyll&lt;/code&gt; 这扇门。&lt;/p&gt;

&lt;h2&gt;声明&lt;/h2&gt;

&lt;p&gt;在下面出现的某些算法思想、核心部分都是继承自BeiYuu。当然也有自己的想法杂烩其中，如不指明，均来自于BeiYuu。&lt;/p&gt;

&lt;h2&gt;界面构建&lt;/h2&gt;

&lt;h3&gt;总体布局&lt;/h3&gt;

&lt;p&gt;此界面主要分两栏，右栏是绝对定位，脱离正常文档流 &lt;code&gt;position:absolute&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;article&amp;gt;
    &amp;lt;!-- 文章内容 --&amp;gt;
&amp;lt;/article&amp;gt;
&amp;lt;aside id=&quot;menuIndex&quot; class=&quot;right&quot;&amp;gt;
    &amp;lt;!-- 目录索引 --&amp;gt;
&amp;lt;/aside&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;文章的详细信息头&lt;/h3&gt;

&lt;p&gt;这里并没有像BeiYuu那样每次的&lt;code&gt;h1&lt;/code&gt;标题都需自己手动书写，简化了一哈，把对 &lt;code&gt;page.title&lt;/code&gt; 等头部信息的处理，放在了 &lt;code&gt;layout&lt;/code&gt; 中，另外，加了不少其他信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;article-title&quot;&amp;gt;
    &amp;lt;h1&amp;gt;&amp;lt;a href=&quot;{{ page.url }}&quot;&amp;gt;{{ page.title }}&amp;lt;/a&amp;gt;&amp;lt;/h1&amp;gt;
    &amp;lt;div class=&quot;clearfix&quot;&amp;gt;
        &amp;lt;div class=&quot;article-post-time left&quot;&amp;gt;
            &amp;lt;span&amp;gt;&amp;amp;#8227;&amp;lt;/span&amp;gt;
            &amp;lt;time class=&quot;date&quot; pubdate=&quot;{{ page.date | date_to_utc | date: '%Y-%m-%d' }}&quot;&amp;gt;{{ page.date | date_to_utc | date: &quot;%Y-%m-%d&quot; }}&amp;lt;/time&amp;gt;
        &amp;lt;/div&amp;gt;
        {% if page.tags != empty %}
        &amp;lt;div class=&quot;article-tags right&quot;&amp;gt;
            &amp;lt;span class=&quot;pure-css-tag&quot;&amp;gt;&amp;amp;nbsp;&amp;lt;/span&amp;gt;
            &amp;lt;span class=&quot;pure-css-tag-behind left&quot;&amp;gt;
                &amp;lt;ul&amp;gt;
                    {% for tag in page.tags %} 
                    &amp;lt;li&amp;gt;
                        &amp;lt;a href=&quot;/tags.html#{{ tag }}&quot;&amp;gt;
                            {{ tag }}
                        &amp;lt;/a&amp;gt;
                        &amp;lt;span&amp;gt;
                            ,
                        &amp;lt;/span&amp;gt;
                    &amp;lt;/li&amp;gt;
                    {% endfor %}
                &amp;lt;/ul&amp;gt;
            &amp;lt;/span&amp;gt; 
        &amp;lt;/div&amp;gt;
        {% endif %}
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;生成目录&lt;/h2&gt;

&lt;p&gt;主要列表的是二级、三级标题。&lt;/p&gt;

&lt;h3&gt;收集信息&lt;/h3&gt;

&lt;p&gt;把文章中标题的内容“拿到”相应数组中，而 id 信息则同步生成出来，写入相应数组。有两条线：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;jquery取出的 &lt;code&gt;h2&lt;/code&gt; 、&lt;code&gt;h3&lt;/code&gt; 的index线；&lt;/li&gt;
&lt;li&gt;自建两个数组的index线，&lt;code&gt;h2&lt;/code&gt; 数组是顺次的不间断的从 &lt;code&gt;0&lt;/code&gt; 依次到 &lt;code&gt;n&lt;/code&gt;，&lt;code&gt;h3&lt;/code&gt; 数组是间断的，对应于相应 &lt;code&gt;h2&lt;/code&gt; 的index&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;下面代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var h2 = [],h3 = [],tmpl = '&amp;lt;ul&amp;gt;',h2index = 0;
$.each($('.article-div-content&amp;gt;h2,.article-div-content&amp;gt;h3'),function(index,item){
    if(item.tagName.toLowerCase() == 'h2'){
        var h2item = {};
        h2item.name = $(item).text();
        h2item.id = 'menuIndex'+index;
        h2.push(h2item);
        h2index++;
    }else{
        var h3item = {};
        h3item.name = $(item).text();
        h3item.id = 'menuIndex'+index;
        if(!h3[h2index-1]){
            h3[h2index-1] = [];
        }
        h3[h2index-1].push(h3item);
    }
    item.id = 'menuIndex' + index
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;生成目录串&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;tmpl += '&amp;lt;li class=&quot;h1&quot;&amp;gt;&amp;lt;a href=&quot;#&quot; data-top=&quot;0&quot;&amp;gt;'+$('.article-title&amp;gt;h1').text()+'&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;';           
for(var i=0;i&amp;lt;h2.length;i++){
    tmpl += '&amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot; data-id=&quot;'+h2[i].id+'&quot;&amp;gt;'+h2[i].name+'&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;';
    if(h3[i]){
        for(var j=0;j&amp;lt;h3[i].length;j++){
            tmpl += '&amp;lt;li class=&quot;h3&quot;&amp;gt;&amp;lt;a href=&quot;#&quot; data-id=&quot;'+h3[i][j].id+'&quot;&amp;gt;'+h3[i][j].name+'&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;';
        }
    }
}
tmpl += '&amp;lt;/ul&amp;gt;';
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;插入目录并赋事件&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Chocolate&lt;/code&gt; 为本博客的一个通用类库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var $scrollable = Chocolate.findScrollableElement('body','html');
$('#menuIndex').append($(tmpl)).delegate('a','click',function(e){
    e.preventDefault();
    var scrollNum = $(this).attr('data-top') || $('#'+$(this).attr('data-id')).offset().top;
    $scrollable.animate({ scrollTop: scrollNum-30 }, 400, 'swing');
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Chocolate 类 findScrollableElement&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;$scrollElement = $(el)&lt;/code&gt; 这个变量以 &lt;code&gt;$&lt;/code&gt; 开头，因为被赋予了一个 JQuery 对象，增强程序的可读性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;findScrollableElement : function(els) {
    for (var i = 0, argLength = arguments.length; i &amp;lt; argLength; i++) {
        var el = arguments[i],
        $scrollElement = $(el);
        var ss=el;
        if ($scrollElement.scrollTop() &amp;gt; 0) {
            return $scrollElement;
        } else {
            $scrollElement.scrollTop(1);
            var isScrollable = $scrollElement.scrollTop() &amp;gt; 0;
            $scrollElement.scrollTop(0);
            if (isScrollable) {
                return $scrollElement;
            }
        }
    }
    return [];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;JQuery 之 scrollTop()&lt;/h3&gt;

&lt;p&gt;“匹配的元素集合中获取第一个元素的滚动条的垂直位置”。&lt;/p&gt;

&lt;p&gt;垂直滚动位置等于浏览器可见区域以上的已经淡出我们视野的隐藏区域。如果滚动条是在最顶部，或者这个元素没有滚动条，那么这个数字是0。当此元素没有滚动条时 &lt;code&gt;scrollTop(value)&lt;/code&gt; 是不起作用的（包括 body,html,window）。理论上，应该只有 window 可滚动，但是，在浏览器有滚动条的情况下，经测试 firefox 和 ie 的可滚动元素为 html、window，而 webkit 内核的浏览器为 body、window。&lt;/p&gt;

&lt;p&gt;既然这样，为什么不直接用 window 呢？like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('#menuIndex').append($(tmpl)).delegate('a','click',function(e){
    e.preventDefault();
    var scrollNum = $(this).attr('data-top') || $('#'+$(this).attr('data-id')).offset().top;
    //window.scrollTo(0,scrollNum-30);
    // $(window).scrollTop(scrollNum-30);
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;两条注释语句，随便开一条，即可以点击时跳转到相应位置。原因是没有滚动效果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(window).animate({ scrollTop: scrollNum-30 }, 400, 'swing');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是没有效果的，window 并不是 dom 元素，而是 window 对象，animate 不起作用。当然我们可以用原生的 javascript 完成滚动效果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//TODO:
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;相应目录项高亮&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;scrollTop&lt;/code&gt;数组中，应该比 &lt;code&gt;$('#menuIndex li')&lt;/code&gt; 集合中 &lt;code&gt;li&lt;/code&gt; 的个数少一个，利用这种特殊关系，通过数值调整，很巧妙地实现了相应目录的高亮。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(window).load(function(){
    var scrollTop = [];
    $.each($('#menuIndex li a'),function(index,item){
        if(!$(item).attr('data-top')){
            var top = $('#'+$(item).attr('data-id')).offset().top;
            scrollTop.push(top);
            $(item).attr('data-top',top);
        }
    });
    $(window).bind('scroll',function(){
        var nowTop = $(window).scrollTop(),index,length = scrollTop.length;
        if(nowTop+60 &amp;gt; scrollTop[length-1]){
            index = length
        }else{
            for(var i=0;i&amp;lt;length;i++){
                if(nowTop+60 &amp;lt;= scrollTop[i]){
                    index = i
                    break;
                }
            }
        }
        $('#menuIndex li').removeClass('on')
        $('#menuIndex li').eq(index).addClass('on')
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;我的改善&lt;/h2&gt;

&lt;p&gt;其实上面的代码中，也有我的小改，不过核心的东西还是来自于 BeiYuu 。下面写一小段判断，很简单，使目录索引随着滚动，不断移动，不断出现在我们的视野中。当没有这一 &lt;code&gt;($(window).height()-60)&amp;gt;$('#menuIndex').height()&lt;/code&gt; 条件时，是很可怕的，一旦 &lt;code&gt;$('#menuIndex').height()&lt;/code&gt; 大于 &lt;code&gt;$(window).height()&lt;/code&gt; 了，滚动条会因为目录区域的溢出可无限往下滚动。之所以 &lt;code&gt;$(window).height()-60&lt;/code&gt; 减 60，是因为本博客的版权高度大概60像素，这样避免了版权区域与目录区域的重叠覆盖。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(window).bind(&quot;scroll&quot;, function(){
    var menuIndex_scrHeight = $(window).scrollTop(),menuIndex_topHeight;
    if(menuIndex_scrHeight &amp;gt; 140 &amp;amp;&amp;amp; ($(window).height()-60)&amp;gt;$('#menuIndex').height()) {
        menuIndex_topHeight = menuIndex_scrHeight-140;
        $('#menuIndex').animate({top: menuIndex_topHeight},10);
    } 
    else{
        $('#menuIndex').animate({top: 0},10);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果减去的 footer 高度很大，岂不是达不到想要的效果，上面这种方法不是很好，或者说很局限，很差，那你可以这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(window).bind(&quot;scroll&quot;, function(){
    var menuIndex_scrHeight = $(window).scrollTop(),menuIndex_topHeight;
    var footerOffsetTop=$('footer').offset().top;
    if(menuIndex_scrHeight &amp;gt; 140 &amp;amp;&amp;amp; menuIndex_scrHeight&amp;lt;(footerOffsetTop-$('#menuIndex').height()) &amp;amp;&amp;amp; $(window).height()&amp;gt;$('#menuIndex').height()) {
        menuIndex_topHeight = menuIndex_scrHeight-140;
        $('#menuIndex').animate({top: menuIndex_topHeight},10);
    } 
    else{
        $('#menuIndex').animate({top: 0},10);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;footerOffsetTop&lt;/code&gt; 这个高度只要保持取到“分栏容器”后的，第一个元素的 &lt;code&gt;.offset().top&lt;/code&gt; 即可&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;不写不知道，很多概念还很模糊，试着解释了一哈，很不到位，不过理解稍微加深了一些。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Demos界面的伪瀑布流布局的实现</title>
     <link href="http://webcraft.malei.tk/articles/water-fall-layout"/>
     <updated>2012-08-07T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/water-fall-layout</id>
     <content type="html">&lt;h2&gt;为什么叫伪瀑布流&lt;/h2&gt;

&lt;p&gt;因为并没有实现动态loading...，也没有用脚本去嗅探浏览器的宽度，以确定具体有几条瀑布。这是由博客的具体情况决定的，因为所有的demo都是慢慢生成的，所以这个Demos界面主要是做了个collection。写的比较死，主要针对本博客所写。&lt;/p&gt;

&lt;h2&gt;liquid脚本&lt;/h2&gt;

&lt;h3&gt;遍历所有demo&lt;/h3&gt;

&lt;p&gt;给每篇文章一个特定的&lt;code&gt;ID&lt;/code&gt;，我这里是从&lt;code&gt;1&lt;/code&gt;开始，即&lt;code&gt;demo-index-1&lt;/code&gt;，因为我在&lt;code&gt;demo-index-0&lt;/code&gt;中存放了所有demo数量的概览，这个总数将由&lt;code&gt;js&lt;/code&gt;获取，留待后用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% assign index = 0 %}
{% for post in site.categories.demos %}
{% capture index %}{{ index | plus:1 }}{% endcapture %}
{% capture demo_index %}demo-index-{{ index }}{% endcapture %}
    &amp;lt;article id=&quot;{{ demo_index }}&quot;&amp;gt;
            &amp;lt;div class=&quot;demo-title&quot;&amp;gt;
                &amp;lt;h3&amp;gt;&amp;lt;a href=&quot;{{ post.url }}&quot;&amp;gt;{{ post.title }}&amp;lt;/a&amp;gt;&amp;lt;/h3&amp;gt;
                &amp;lt;p&amp;gt;{{ post.description }}&amp;lt;/p&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;demo-time&quot;&amp;gt;
                &amp;lt;p&amp;gt;&amp;lt;span&amp;gt;&amp;amp;#8227;&amp;lt;/span&amp;gt;&amp;lt;time pubdate=&quot;{{ post.date | date: '%b %d, %Y' }}&quot;&amp;gt;{{ post.date | date: '%b %d, %Y' }}&amp;lt;/time&amp;gt;&amp;lt;/p&amp;gt;
            &amp;lt;/div&amp;gt;
    &amp;lt;/article&amp;gt;
{% endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;demo数量概览&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;article id=&quot;demo-index-0&quot;&amp;gt;
    {% capture list_size %}{{ site.categories.demos | size }}{% endcapture %}
    &amp;lt;h3&amp;gt;
        All demos:
        (&amp;lt;span&amp;gt;
            {{list_size}}
        &amp;lt;/span&amp;gt;)
    &amp;lt;/h3&amp;gt;         
&amp;lt;/article&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;给出瀑布流容器&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;waterFallContainer&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;生成瀑布&lt;/h2&gt;

&lt;p&gt;主要就是用&lt;code&gt;js&lt;/code&gt;操作&lt;code&gt;DOM&lt;/code&gt;树，把文档呈现成自己想要的样子。&lt;/p&gt;

&lt;h3&gt;首先声明一个静态类&lt;/h3&gt;

&lt;p&gt;这里声明了如下属性、方法。具体分了5条瀑布，下面分别介绍每个方法的作用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var waterFall = {
    container: $(&quot;#waterFallContainer&quot;),
    columnNumber: 5,
    columnWidth: 184,
    demoIndex: 0,
    loadFinish: false,
    demosNum: parseInt($('#demo-index-0 span').text())+1,
    create: function(){  },
    loadAllDemos: function() {  },
    loadSingleDemo: function(column) {  },
    init:function(){  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;生成空瀑布&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;create: function(){
    var start=0, spans = '';
    for (start; start &amp;lt; this.columnNumber; start++) {
        spans = spans + '&amp;lt;span id=&quot;waterFallColumn-'+ start +'&quot; class=&quot;waterFallColumns&quot; style=&quot;width:'+ this.columnWidth +'px;&quot;&amp;gt;'+ '&amp;lt;/span&amp;gt; ';
    }
    this.container.html(spans);
    return this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;填入内容&lt;/h3&gt;

&lt;p&gt;把所有的demo剪切到瀑布流容器中。首先，在剪切一个节点前，先判断是否所有demo都已加载完毕。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;loadSingleDemo: function(column) {

    if (this.demoIndex &amp;gt; this.demosNum) {
        this.loadFinish = true;
    }
    else{
        column.append($(&quot;#demo-index-&quot;+this.demoIndex));
        this.demoIndex += 1;
    }
    return this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其次，有了上述方法，就可以放心的加载了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;loadAllDemos: function() {
    var index=0;
    for(index;index&amp;lt;this.demosNum;index +=5){
        var start = 0;
        for (start; start &amp;lt; this.columnNumber; start++) {
            var eleColumn = $(&quot;#waterFallColumn-&quot; + start);
            if (eleColumn &amp;amp;&amp;amp; !this.loadFinish) {
                this.loadSingleDemo(eleColumn);
            }           
        }
    }
    return this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;初始化&lt;/h3&gt;

&lt;p&gt;每个方法都&lt;code&gt;return this;&lt;/code&gt;,这样就可以像下面连着写了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;init:function(){
    this.create().loadAllDemos();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;FAQ&lt;/h2&gt;

&lt;p&gt;这里我遇到了一个问题，纠结了半天也没解决。本来想着 &lt;code&gt;span&lt;/code&gt;的&lt;code&gt;display:inline-block&lt;/code&gt; 就可以能解决问题了，诡异的是&lt;code&gt;span&lt;/code&gt;之间总有5像素的间隔（ps:&lt;code&gt;span&lt;/code&gt;的&lt;code&gt;margin&lt;/code&gt;为&lt;code&gt;0&lt;/code&gt;），怎么也找不出是哪的猫腻。于是乎，&lt;code&gt;display:block;float:left;&lt;/code&gt;。纠结啊。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Tags界面构建之123</title>
     <link href="http://webcraft.malei.tk/articles/tags-js-liquid"/>
     <updated>2012-08-06T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/tags-js-liquid</id>
     <content type="html">&lt;h2&gt;起因&lt;/h2&gt;

&lt;p&gt;说道产生这种想法的起因，刚开始，想的是点击一个按钮链接，在 &lt;code&gt;location&lt;/code&gt; 中产生相应的锚，这样用&lt;code&gt;js&lt;/code&gt;获取锚中的值，就可以实现无论在tags界面还是文章界面，都能用这一种做法实现显示相应的文章。&lt;/p&gt;

&lt;h2&gt;错误的方向&lt;/h2&gt;

&lt;p&gt;在构建tags界面当时，鬼迷了心窍，一心想着&lt;code&gt;js&lt;/code&gt;与&lt;code&gt;liquid&lt;/code&gt;脚本交互，根本没有想可行性。尝试了各种蹩脚的方法尝试&lt;code&gt;js&lt;/code&gt;向&lt;code&gt;liquid&lt;/code&gt;传参，都失败了。现在想想，当时真是傻透了，白白的浪费了大量的时间。&lt;/p&gt;

&lt;h2&gt;放弃vs转机&lt;/h2&gt;

&lt;p&gt;大概浪费了半天时间纠结于传参问题，要命的是当时已把&lt;code&gt;jekyll&lt;/code&gt;的工作原理抛向脑后，还咒骂过&lt;code&gt;jekyll&lt;/code&gt;的&lt;code&gt;liquid&lt;/code&gt;脚本竟然不提供与&lt;code&gt;js&lt;/code&gt;的交互。渐渐地，心气儿被时间磨平了，于是就放弃了（在放弃的那一刻，我还坚信着他们之间一定能传参，只是我还没有找对路子）。说到转机，其实并不是传参这件事，而是用&lt;code&gt;liquid&lt;/code&gt;脚本遍历出所有的&lt;code&gt;tag&lt;/code&gt;，然后用&lt;code&gt;js&lt;/code&gt;达到自己想要的效果。&lt;/p&gt;

&lt;h2&gt;为什么不能传参&lt;/h2&gt;

&lt;p&gt;因为&lt;code&gt;jekyll&lt;/code&gt;是静态的，在把代码注入到&lt;code&gt;_site&lt;/code&gt;文件夹时，&lt;code&gt;liquid&lt;/code&gt;脚本已然运行了，根本没有交互的机会，他们的生存期错开了。&lt;/p&gt;

&lt;h2&gt;小效果的实现&lt;/h2&gt;

&lt;p&gt;site.tags一览&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;site = {
    &quot;tags&quot;=&amp;gt;
    {
     &quot;permalinks&quot;=&amp;gt;
      [...(Array of liquified Jekyll::Post objects)...],
     &quot;urls&quot;=&amp;gt;
      [...(Array of liquified Jekyll::Post objects)...],
     &quot;templating&quot;=&amp;gt;
      [...(Array of liquified Jekyll::Post objects)...],
     &quot;liquid&quot;=&amp;gt;
      [...(Array of liquified Jekyll::Post objects)...],
     &quot;posts&quot;=&amp;gt;
      [...(Array of liquified Jekyll::Post objects)...]
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;遍历tags&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;{% assign tags_list = site.tags %}  
{% for tag in tags_list %} 
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;/tags.html#{{ tag[0] }}&quot;&amp;gt;&amp;lt;span class=&quot;tag-name&quot;&amp;gt;{{ tag[0] }}&amp;lt;span&amp;gt;({{ tagsize }})&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
{% endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;遍历相应tag的文章&lt;/h3&gt;

&lt;p&gt;每一类tag的文章放入一个&lt;code&gt;div&lt;/code&gt;中，其&lt;code&gt;id&lt;/code&gt;为&lt;code&gt;{{ tag[0] }}-ref&lt;/code&gt;,防止被锚点跟踪。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% for tag in site.tags %}
&amp;lt;div class=&quot;articles-for-the-tag none&quot; id=&quot;{{ tag[0] }}-ref&quot;&amp;gt;
    &amp;lt;h3 class=&quot;tag-name&quot;&amp;gt;{{ tag[0] }}&amp;lt;/h3&amp;gt;
    {% assign articles_list = tag[1] %}  
    {% for node in articles_list %}
        {% if node.title != null %}
            &amp;lt;article&amp;gt;
                &amp;lt;div class=&quot;article-head&quot;&amp;gt;
                    &amp;lt;h3&amp;gt;&amp;lt;a href=&quot;{{ node.url }}&quot;&amp;gt;{{ node.title }}&amp;lt;/a&amp;gt;&amp;lt;/h3&amp;gt;
                    &amp;lt;div class=&quot;clearfix&quot;&amp;gt;
                        &amp;lt;div class=&quot;article-post-time left&quot;&amp;gt;
                            &amp;lt;span&amp;gt;&amp;amp;#8227;&amp;lt;/span&amp;gt;
                            &amp;lt;time pubdate=&quot;{{ node.date | date: '%b %d, %Y' }}&quot;&amp;gt;{{ node.date | date: '%b %d, %Y' }}&amp;lt;/time&amp;gt;
                        &amp;lt;/div&amp;gt;
                    &amp;lt;/div&amp;gt;
                &amp;lt;/div&amp;gt;
                &amp;lt;div class=&quot;article-body&quot;&amp;gt;
                    &amp;lt;p&amp;gt;{{ node.description }}&amp;lt;/p&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/article&amp;gt;
        {% endif %}
    {% endfor %}
&amp;lt;/div&amp;gt;
{% endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;显示&lt;/h3&gt;

&lt;p&gt;刚开始，所有的文章都&lt;code&gt;display:none&lt;/code&gt;，等到触发相应事件后，显示相应tag的文章。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(function(){
    var param=Chocolate.getParameterFromURL();
    if(param !== &quot;&quot;){
        $('#all-tags').css('width','290px');
        $('#all-articles').animate({width:'660px'});
        $('#'+param+'-ref').slideDown();
    }
    $('#all-tags ul li a').bind('click',  function() {
        $('#all-tags').css('width','290px');
        $('#all-articles').animate({width:'660px'});
        var tagName=$(this).children('span.tag-name').text();
        $('.articles-for-the-tag').slideUp();
        $('#'+tagName+'-ref').slideDown();
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了达到与整体博客的融合，tags界面采用的是左文章、右标签的布局。为了使点击tag时，文章显示的不那么突兀，配合CSS,做了个拉动效果。&lt;/p&gt;

&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;虽然历经坎坷，但终于还是有了一个令自己看着还行的的效果。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>ana...</title>
     <link href="http://webcraft.malei.tk/articles/ana"/>
     <updated>2012-08-02T00:00:00+08:00</updated>
     <id>http://webcraft.malei.tk/articles/ana</id>
     <content type="html">&lt;p&gt;在一回首间，才忽然发现，原来，我一生的种种努力，不过只为了周遭的人对我满意而已。为了博得他人的称许与微笑，我战战兢兢地将自己套入所有的模式所有的桎梏。走到途中才忽然发现，我只剩下一副模糊的面目，和一条不能回头的路。（席慕容）&lt;/p&gt;
</content>
   </entry>
   
 
</feed>
